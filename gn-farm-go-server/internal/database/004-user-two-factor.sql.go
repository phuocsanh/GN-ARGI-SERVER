// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 004-user-two-factor.sql

package database

import (
	"context"
	"database/sql"
)

const addOrUpdateEmail = `-- name: AddOrUpdateEmail :exec
INSERT INTO user_two_factors (user_id, two_factor_auth_type, two_factor_email, two_factor_is_active)
VALUES ($1, 'EMAIL', $2, TRUE) -- Use $1, $2 placeholders, assuming type is EMAIL
ON CONFLICT (user_id, two_factor_auth_type) DO UPDATE SET 
    two_factor_email = EXCLUDED.two_factor_email, 
    two_factor_is_active = TRUE, -- Ensure it stays active on update
    two_factor_updated_at = NOW()
`

type AddOrUpdateEmailParams struct {
	UserID         int32          `json:"userId"`
	TwoFactorEmail sql.NullString `json:"twoFactorEmail"`
}

// AddOrUpdateEmail
// Assuming a UNIQUE constraint exists on (user_id, two_factor_auth_type) for ON CONFLICT
func (q *Queries) AddOrUpdateEmail(ctx context.Context, arg AddOrUpdateEmailParams) error {
	_, err := q.db.ExecContext(ctx, addOrUpdateEmail, arg.UserID, arg.TwoFactorEmail)
	return err
}

const addOrUpdatePhoneNumber = `-- name: AddOrUpdatePhoneNumber :exec

INSERT INTO user_two_factors (user_id, two_factor_auth_type, two_factor_phone, two_factor_is_active)
VALUES ($1, 'SMS', $2, TRUE) -- Use $1, $2 placeholders, assuming type is SMS
ON CONFLICT (user_id, two_factor_auth_type) DO UPDATE SET 
    two_factor_phone = EXCLUDED.two_factor_phone, 
    two_factor_is_active = TRUE, -- Ensure it stays active on update
    two_factor_updated_at = NOW()
`

type AddOrUpdatePhoneNumberParams struct {
	UserID         int32          `json:"userId"`
	TwoFactorPhone sql.NullString `json:"twoFactorPhone"`
}

// Use $1 placeholder
// AddOrUpdatePhoneNumber
// Assuming a UNIQUE constraint exists on (user_id, two_factor_auth_type) for ON CONFLICT
func (q *Queries) AddOrUpdatePhoneNumber(ctx context.Context, arg AddOrUpdatePhoneNumberParams) error {
	_, err := q.db.ExecContext(ctx, addOrUpdatePhoneNumber, arg.UserID, arg.TwoFactorPhone)
	return err
}

const countActiveTwoFactorMethods = `-- name: CountActiveTwoFactorMethods :one

SELECT COUNT(*)
FROM user_two_factors
WHERE user_id = $1 AND two_factor_is_active = TRUE
`

// Use $1, $2 placeholders
// CountActiveTwoFactorMethods
func (q *Queries) CountActiveTwoFactorMethods(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveTwoFactorMethods, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const disableTwoFactor = `-- name: DisableTwoFactor :exec

UPDATE user_two_factors
SET two_factor_is_active = FALSE, 
    two_factor_updated_at = NOW()
WHERE user_id = $1 AND two_factor_auth_type = $2
`

type DisableTwoFactorParams struct {
	UserID            int32  `json:"userId"`
	TwoFactorAuthType string `json:"twoFactorAuthType"`
}

// Use $1..$3 placeholders, kept 'OTP' as string literal
// DisableTwoFactor
func (q *Queries) DisableTwoFactor(ctx context.Context, arg DisableTwoFactorParams) error {
	_, err := q.db.ExecContext(ctx, disableTwoFactor, arg.UserID, arg.TwoFactorAuthType)
	return err
}

const enableTwoFactorTypeEmail = `-- name: EnableTwoFactorTypeEmail :exec

INSERT INTO user_two_factors (user_id, two_factor_auth_type, two_factor_email, two_factor_auth_secret, two_factor_is_active, two_factor_created_at, two_factor_updated_at)
VALUES ($1, $2, $3, 'OTP', FALSE, NOW(), NOW())
`

type EnableTwoFactorTypeEmailParams struct {
	UserID            int32          `json:"userId"`
	TwoFactorAuthType string         `json:"twoFactorAuthType"`
	TwoFactorEmail    sql.NullString `json:"twoFactorEmail"`
}

// file: user_two_factors.sql
// EnableTwoFactor
// Note: Inserting "OTP" as secret might need review based on actual logic.
func (q *Queries) EnableTwoFactorTypeEmail(ctx context.Context, arg EnableTwoFactorTypeEmailParams) error {
	_, err := q.db.ExecContext(ctx, enableTwoFactorTypeEmail, arg.UserID, arg.TwoFactorAuthType, arg.TwoFactorEmail)
	return err
}

const getTwoFactorMethodByID = `-- name: GetTwoFactorMethodByID :one

SELECT two_factor_id, user_id, two_factor_auth_type, two_factor_auth_secret, 
       two_factor_phone, two_factor_email, 
       two_factor_is_active, two_factor_created_at, two_factor_updated_at
FROM user_two_factors
WHERE two_factor_id = $1
`

// Use $1 placeholder
// GetTwoFactorMethodByID
func (q *Queries) GetTwoFactorMethodByID(ctx context.Context, twoFactorID int32) (UserTwoFactor, error) {
	row := q.db.QueryRowContext(ctx, getTwoFactorMethodByID, twoFactorID)
	var i UserTwoFactor
	err := row.Scan(
		&i.TwoFactorID,
		&i.UserID,
		&i.TwoFactorAuthType,
		&i.TwoFactorAuthSecret,
		&i.TwoFactorPhone,
		&i.TwoFactorEmail,
		&i.TwoFactorIsActive,
		&i.TwoFactorCreatedAt,
		&i.TwoFactorUpdatedAt,
	)
	return i, err
}

const getTwoFactorMethodByIDAndType = `-- name: GetTwoFactorMethodByIDAndType :one

SELECT two_factor_id, user_id, two_factor_auth_type, two_factor_auth_secret, 
       two_factor_phone, two_factor_email, 
       two_factor_is_active, two_factor_created_at, two_factor_updated_at
FROM user_two_factors
WHERE user_id = $1 AND two_factor_auth_type = $2
`

type GetTwoFactorMethodByIDAndTypeParams struct {
	UserID            int32  `json:"userId"`
	TwoFactorAuthType string `json:"twoFactorAuthType"`
}

// Use $1 placeholder
// GetTwoFactorMethodByIDAndType: select lay email de sen otp
func (q *Queries) GetTwoFactorMethodByIDAndType(ctx context.Context, arg GetTwoFactorMethodByIDAndTypeParams) (UserTwoFactor, error) {
	row := q.db.QueryRowContext(ctx, getTwoFactorMethodByIDAndType, arg.UserID, arg.TwoFactorAuthType)
	var i UserTwoFactor
	err := row.Scan(
		&i.TwoFactorID,
		&i.UserID,
		&i.TwoFactorAuthType,
		&i.TwoFactorAuthSecret,
		&i.TwoFactorPhone,
		&i.TwoFactorEmail,
		&i.TwoFactorIsActive,
		&i.TwoFactorCreatedAt,
		&i.TwoFactorUpdatedAt,
	)
	return i, err
}

const getTwoFactorStatus = `-- name: GetTwoFactorStatus :one

SELECT two_factor_is_active
FROM user_two_factors
WHERE user_id = $1 AND two_factor_auth_type = $2
`

type GetTwoFactorStatusParams struct {
	UserID            int32  `json:"userId"`
	TwoFactorAuthType string `json:"twoFactorAuthType"`
}

// Use $1, $2 placeholders
// GetTwoFactorStatus
func (q *Queries) GetTwoFactorStatus(ctx context.Context, arg GetTwoFactorStatusParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, getTwoFactorStatus, arg.UserID, arg.TwoFactorAuthType)
	var two_factor_is_active bool
	err := row.Scan(&two_factor_is_active)
	return two_factor_is_active, err
}

const getUserTwoFactorMethods = `-- name: GetUserTwoFactorMethods :many
SELECT two_factor_id, user_id, two_factor_auth_type, two_factor_auth_secret, 
       two_factor_phone, two_factor_email, 
       two_factor_is_active, two_factor_created_at, two_factor_updated_at
FROM user_two_factors
WHERE user_id = $1
`

// GetUserTwoFactorMethods
func (q *Queries) GetUserTwoFactorMethods(ctx context.Context, userID int32) ([]UserTwoFactor, error) {
	rows, err := q.db.QueryContext(ctx, getUserTwoFactorMethods, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTwoFactor
	for rows.Next() {
		var i UserTwoFactor
		if err := rows.Scan(
			&i.TwoFactorID,
			&i.UserID,
			&i.TwoFactorAuthType,
			&i.TwoFactorAuthSecret,
			&i.TwoFactorPhone,
			&i.TwoFactorEmail,
			&i.TwoFactorIsActive,
			&i.TwoFactorCreatedAt,
			&i.TwoFactorUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isTwoFactorEnabled = `-- name: IsTwoFactorEnabled :one

SELECT COUNT(*)
FROM user_two_factors
WHERE user_id = $1 AND two_factor_is_active = TRUE
`

// Use $1, $2 placeholders
// IsTwoFactorEnabled
func (q *Queries) IsTwoFactorEnabled(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, isTwoFactorEnabled, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const reactivateTwoFactor = `-- name: ReactivateTwoFactor :exec

UPDATE user_two_factors
SET two_factor_is_active = TRUE, 
    two_factor_updated_at = NOW()
WHERE user_id = $1 AND two_factor_auth_type = $2
`

type ReactivateTwoFactorParams struct {
	UserID            int32  `json:"userId"`
	TwoFactorAuthType string `json:"twoFactorAuthType"`
}

// Use $1 placeholder
// ReactivateTwoFactor
func (q *Queries) ReactivateTwoFactor(ctx context.Context, arg ReactivateTwoFactorParams) error {
	_, err := q.db.ExecContext(ctx, reactivateTwoFactor, arg.UserID, arg.TwoFactorAuthType)
	return err
}

const removeTwoFactor = `-- name: RemoveTwoFactor :exec

DELETE FROM user_two_factors
WHERE user_id = $1 AND two_factor_auth_type = $2
`

type RemoveTwoFactorParams struct {
	UserID            int32  `json:"userId"`
	TwoFactorAuthType string `json:"twoFactorAuthType"`
}

// Use $1, $2 placeholders
// RemoveTwoFactor
func (q *Queries) RemoveTwoFactor(ctx context.Context, arg RemoveTwoFactorParams) error {
	_, err := q.db.ExecContext(ctx, removeTwoFactor, arg.UserID, arg.TwoFactorAuthType)
	return err
}

const updateTwoFactorStatus = `-- name: UpdateTwoFactorStatus :exec

UPDATE user_two_factors
SET two_factor_is_active = TRUE, two_factor_updated_at = NOW()
WHERE user_id = $1 AND two_factor_auth_type = $2 AND two_factor_is_active = FALSE
`

type UpdateTwoFactorStatusParams struct {
	UserID            int32  `json:"userId"`
	TwoFactorAuthType string `json:"twoFactorAuthType"`
}

// Use $1, $2 placeholders
// UpdateTwoFactorStatusVerification
func (q *Queries) UpdateTwoFactorStatus(ctx context.Context, arg UpdateTwoFactorStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTwoFactorStatus, arg.UserID, arg.TwoFactorAuthType)
	return err
}

const verifyTwoFactor = `-- name: VerifyTwoFactor :one

SELECT COUNT(*)
FROM user_two_factors
WHERE user_id = $1 AND two_factor_auth_type = $2 AND two_factor_is_active = TRUE
`

type VerifyTwoFactorParams struct {
	UserID            int32  `json:"userId"`
	TwoFactorAuthType string `json:"twoFactorAuthType"`
}

// Use $1, $2 placeholders
// VerifyTwoFactor
func (q *Queries) VerifyTwoFactor(ctx context.Context, arg VerifyTwoFactorParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, verifyTwoFactor, arg.UserID, arg.TwoFactorAuthType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

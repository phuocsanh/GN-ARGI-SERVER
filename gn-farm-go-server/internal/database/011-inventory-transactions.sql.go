// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 011-inventory-transactions.sql

package database

import (
	"context"
	"database/sql"
)

const calculateWeightedAverageCost = `-- name: CalculateWeightedAverageCost :one
SELECT 
    COALESCE(SUM(remaining_quantity * unit_cost_price) / NULLIF(SUM(remaining_quantity), 0), 0) as weighted_average_cost,
    COALESCE(SUM(remaining_quantity), 0) as total_quantity
FROM inventory_batches 
WHERE product_id = $1 AND remaining_quantity > 0
`

type CalculateWeightedAverageCostRow struct {
	WeightedAverageCost interface{} `json:"weightedAverageCost"`
	TotalQuantity       interface{} `json:"totalQuantity"`
}

func (q *Queries) CalculateWeightedAverageCost(ctx context.Context, productID int32) (CalculateWeightedAverageCostRow, error) {
	row := q.db.QueryRowContext(ctx, calculateWeightedAverageCost, productID)
	var i CalculateWeightedAverageCostRow
	err := row.Scan(&i.WeightedAverageCost, &i.TotalQuantity)
	return i, err
}

const createInventoryBatch = `-- name: CreateInventoryBatch :one
INSERT INTO inventory_batches (
    product_id, batch_code, unit_cost_price, original_quantity, 
    remaining_quantity, expiry_date, receipt_item_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, product_id, batch_code, unit_cost_price, original_quantity, remaining_quantity, expiry_date, receipt_item_id, created_at, updated_at
`

type CreateInventoryBatchParams struct {
	ProductID         int32          `json:"productId"`
	BatchCode         sql.NullString `json:"batchCode"`
	UnitCostPrice     string         `json:"unitCostPrice"`
	OriginalQuantity  int32          `json:"originalQuantity"`
	RemainingQuantity int32          `json:"remainingQuantity"`
	ExpiryDate        sql.NullTime   `json:"expiryDate"`
	ReceiptItemID     sql.NullInt32  `json:"receiptItemId"`
}

func (q *Queries) CreateInventoryBatch(ctx context.Context, arg CreateInventoryBatchParams) (InventoryBatch, error) {
	row := q.db.QueryRowContext(ctx, createInventoryBatch,
		arg.ProductID,
		arg.BatchCode,
		arg.UnitCostPrice,
		arg.OriginalQuantity,
		arg.RemainingQuantity,
		arg.ExpiryDate,
		arg.ReceiptItemID,
	)
	var i InventoryBatch
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.BatchCode,
		&i.UnitCostPrice,
		&i.OriginalQuantity,
		&i.RemainingQuantity,
		&i.ExpiryDate,
		&i.ReceiptItemID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInventoryTransaction = `-- name: CreateInventoryTransaction :one
INSERT INTO inventory_transactions (
    product_id, transaction_type, quantity, unit_cost_price, total_cost_value,
    remaining_quantity, new_average_cost, receipt_item_id, reference_type, 
    reference_id, notes, created_by_user_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, product_id, transaction_type, quantity, unit_cost_price, total_cost_value, remaining_quantity, new_average_cost, receipt_item_id, reference_type, reference_id, notes, created_by_user_id, created_at, updated_at
`

type CreateInventoryTransactionParams struct {
	ProductID         int32          `json:"productId"`
	TransactionType   string         `json:"transactionType"`
	Quantity          int32          `json:"quantity"`
	UnitCostPrice     string         `json:"unitCostPrice"`
	TotalCostValue    string         `json:"totalCostValue"`
	RemainingQuantity int32          `json:"remainingQuantity"`
	NewAverageCost    string         `json:"newAverageCost"`
	ReceiptItemID     sql.NullInt32  `json:"receiptItemId"`
	ReferenceType     sql.NullString `json:"referenceType"`
	ReferenceID       sql.NullInt32  `json:"referenceId"`
	Notes             sql.NullString `json:"notes"`
	CreatedByUserID   int32          `json:"createdByUserId"`
}

func (q *Queries) CreateInventoryTransaction(ctx context.Context, arg CreateInventoryTransactionParams) (InventoryTransaction, error) {
	row := q.db.QueryRowContext(ctx, createInventoryTransaction,
		arg.ProductID,
		arg.TransactionType,
		arg.Quantity,
		arg.UnitCostPrice,
		arg.TotalCostValue,
		arg.RemainingQuantity,
		arg.NewAverageCost,
		arg.ReceiptItemID,
		arg.ReferenceType,
		arg.ReferenceID,
		arg.Notes,
		arg.CreatedByUserID,
	)
	var i InventoryTransaction
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.TransactionType,
		&i.Quantity,
		&i.UnitCostPrice,
		&i.TotalCostValue,
		&i.RemainingQuantity,
		&i.NewAverageCost,
		&i.ReceiptItemID,
		&i.ReferenceType,
		&i.ReferenceID,
		&i.Notes,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExpiredBatches = `-- name: GetExpiredBatches :many
SELECT id, product_id, batch_code, unit_cost_price, original_quantity, remaining_quantity, expiry_date, receipt_item_id, created_at, updated_at FROM inventory_batches 
WHERE expiry_date IS NOT NULL 
  AND expiry_date <= $1 
  AND remaining_quantity > 0 
ORDER BY expiry_date ASC
`

func (q *Queries) GetExpiredBatches(ctx context.Context, expiryDate sql.NullTime) ([]InventoryBatch, error) {
	rows, err := q.db.QueryContext(ctx, getExpiredBatches, expiryDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryBatch
	for rows.Next() {
		var i InventoryBatch
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.BatchCode,
			&i.UnitCostPrice,
			&i.OriginalQuantity,
			&i.RemainingQuantity,
			&i.ExpiryDate,
			&i.ReceiptItemID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryBatchesByProduct = `-- name: GetInventoryBatchesByProduct :many
SELECT id, product_id, batch_code, unit_cost_price, original_quantity, remaining_quantity, expiry_date, receipt_item_id, created_at, updated_at FROM inventory_batches 
WHERE product_id = $1 AND remaining_quantity > 0 
ORDER BY created_at ASC
`

func (q *Queries) GetInventoryBatchesByProduct(ctx context.Context, productID int32) ([]InventoryBatch, error) {
	rows, err := q.db.QueryContext(ctx, getInventoryBatchesByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryBatch
	for rows.Next() {
		var i InventoryBatch
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.BatchCode,
			&i.UnitCostPrice,
			&i.OriginalQuantity,
			&i.RemainingQuantity,
			&i.ExpiryDate,
			&i.ReceiptItemID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryTransactionsByProduct = `-- name: GetInventoryTransactionsByProduct :many
SELECT id, product_id, transaction_type, quantity, unit_cost_price, total_cost_value, remaining_quantity, new_average_cost, receipt_item_id, reference_type, reference_id, notes, created_by_user_id, created_at, updated_at FROM inventory_transactions 
WHERE product_id = $1 
ORDER BY created_at DESC, id DESC
LIMIT $2 OFFSET $3
`

type GetInventoryTransactionsByProductParams struct {
	ProductID int32 `json:"productId"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetInventoryTransactionsByProduct(ctx context.Context, arg GetInventoryTransactionsByProductParams) ([]InventoryTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getInventoryTransactionsByProduct, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryTransaction
	for rows.Next() {
		var i InventoryTransaction
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.TransactionType,
			&i.Quantity,
			&i.UnitCostPrice,
			&i.TotalCostValue,
			&i.RemainingQuantity,
			&i.NewAverageCost,
			&i.ReceiptItemID,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.Notes,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryTransactionsByReference = `-- name: GetInventoryTransactionsByReference :many
SELECT id, product_id, transaction_type, quantity, unit_cost_price, total_cost_value, remaining_quantity, new_average_cost, receipt_item_id, reference_type, reference_id, notes, created_by_user_id, created_at, updated_at FROM inventory_transactions 
WHERE reference_type = $1 AND reference_id = $2 
ORDER BY created_at DESC
`

type GetInventoryTransactionsByReferenceParams struct {
	ReferenceType sql.NullString `json:"referenceType"`
	ReferenceID   sql.NullInt32  `json:"referenceId"`
}

func (q *Queries) GetInventoryTransactionsByReference(ctx context.Context, arg GetInventoryTransactionsByReferenceParams) ([]InventoryTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getInventoryTransactionsByReference, arg.ReferenceType, arg.ReferenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryTransaction
	for rows.Next() {
		var i InventoryTransaction
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.TransactionType,
			&i.Quantity,
			&i.UnitCostPrice,
			&i.TotalCostValue,
			&i.RemainingQuantity,
			&i.NewAverageCost,
			&i.ReceiptItemID,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.Notes,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryValueReport = `-- name: GetInventoryValueReport :many
SELECT 
    p.id, p.product_name, p.average_cost_price, p.product_quantity,
    COALESCE(SUM(ib.remaining_quantity), 0) as batch_total_quantity,
    COALESCE(SUM(ib.remaining_quantity * ib.unit_cost_price), 0) as total_inventory_value
FROM products p
LEFT JOIN inventory_batches ib ON p.id = ib.product_id AND ib.remaining_quantity > 0
WHERE p.is_published = true
GROUP BY p.id, p.product_name, p.average_cost_price, p.product_quantity
ORDER BY total_inventory_value DESC
`

type GetInventoryValueReportRow struct {
	ID                  int32         `json:"id"`
	ProductName         string        `json:"productName"`
	AverageCostPrice    string        `json:"averageCostPrice"`
	ProductQuantity     sql.NullInt32 `json:"productQuantity"`
	BatchTotalQuantity  interface{}   `json:"batchTotalQuantity"`
	TotalInventoryValue interface{}   `json:"totalInventoryValue"`
}

func (q *Queries) GetInventoryValueReport(ctx context.Context) ([]GetInventoryValueReportRow, error) {
	rows, err := q.db.QueryContext(ctx, getInventoryValueReport)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInventoryValueReportRow
	for rows.Next() {
		var i GetInventoryValueReportRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.AverageCostPrice,
			&i.ProductQuantity,
			&i.BatchTotalQuantity,
			&i.TotalInventoryValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestInventoryTransaction = `-- name: GetLatestInventoryTransaction :one
SELECT id, product_id, transaction_type, quantity, unit_cost_price, total_cost_value, remaining_quantity, new_average_cost, receipt_item_id, reference_type, reference_id, notes, created_by_user_id, created_at, updated_at FROM inventory_transactions 
WHERE product_id = $1 
ORDER BY created_at DESC, id DESC 
LIMIT 1
`

func (q *Queries) GetLatestInventoryTransaction(ctx context.Context, productID int32) (InventoryTransaction, error) {
	row := q.db.QueryRowContext(ctx, getLatestInventoryTransaction, productID)
	var i InventoryTransaction
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.TransactionType,
		&i.Quantity,
		&i.UnitCostPrice,
		&i.TotalCostValue,
		&i.RemainingQuantity,
		&i.NewAverageCost,
		&i.ReceiptItemID,
		&i.ReferenceType,
		&i.ReferenceID,
		&i.Notes,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLowStockProducts = `-- name: GetLowStockProducts :many
SELECT 
    p.id, p.product_name, p.product_quantity, p.average_cost_price,
    COALESCE(SUM(ib.remaining_quantity), 0) as actual_stock
FROM products p
LEFT JOIN inventory_batches ib ON p.id = ib.product_id AND ib.remaining_quantity > 0
WHERE p.product_quantity <= $1
GROUP BY p.id, p.product_name, p.product_quantity, p.average_cost_price
ORDER BY p.product_quantity ASC
`

type GetLowStockProductsRow struct {
	ID               int32         `json:"id"`
	ProductName      string        `json:"productName"`
	ProductQuantity  sql.NullInt32 `json:"productQuantity"`
	AverageCostPrice string        `json:"averageCostPrice"`
	ActualStock      interface{}   `json:"actualStock"`
}

func (q *Queries) GetLowStockProducts(ctx context.Context, productQuantity sql.NullInt32) ([]GetLowStockProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLowStockProducts, productQuantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockProductsRow
	for rows.Next() {
		var i GetLowStockProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductQuantity,
			&i.AverageCostPrice,
			&i.ActualStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductCostInfo = `-- name: GetProductCostInfo :one
SELECT 
    id, product_name, average_cost_price, profit_margin_percent,
    product_price, product_discounted_price, product_quantity
FROM products 
WHERE id = $1
`

type GetProductCostInfoRow struct {
	ID                     int32         `json:"id"`
	ProductName            string        `json:"productName"`
	AverageCostPrice       string        `json:"averageCostPrice"`
	ProfitMarginPercent    string        `json:"profitMarginPercent"`
	ProductPrice           string        `json:"productPrice"`
	ProductDiscountedPrice string        `json:"productDiscountedPrice"`
	ProductQuantity        sql.NullInt32 `json:"productQuantity"`
}

func (q *Queries) GetProductCostInfo(ctx context.Context, id int32) (GetProductCostInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getProductCostInfo, id)
	var i GetProductCostInfoRow
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.AverageCostPrice,
		&i.ProfitMarginPercent,
		&i.ProductPrice,
		&i.ProductDiscountedPrice,
		&i.ProductQuantity,
	)
	return i, err
}

const updateInventoryBatchQuantity = `-- name: UpdateInventoryBatchQuantity :one

UPDATE inventory_batches 
SET remaining_quantity = $2, updated_at = NOW() 
WHERE id = $1 
RETURNING id, product_id, batch_code, unit_cost_price, original_quantity, remaining_quantity, expiry_date, receipt_item_id, created_at, updated_at
`

type UpdateInventoryBatchQuantityParams struct {
	ID                int32 `json:"id"`
	RemainingQuantity int32 `json:"remainingQuantity"`
}

// FIFO: lấy lô cũ nhất trước
func (q *Queries) UpdateInventoryBatchQuantity(ctx context.Context, arg UpdateInventoryBatchQuantityParams) (InventoryBatch, error) {
	row := q.db.QueryRowContext(ctx, updateInventoryBatchQuantity, arg.ID, arg.RemainingQuantity)
	var i InventoryBatch
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.BatchCode,
		&i.UnitCostPrice,
		&i.OriginalQuantity,
		&i.RemainingQuantity,
		&i.ExpiryDate,
		&i.ReceiptItemID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductAverageCostAndPrice = `-- name: UpdateProductAverageCostAndPrice :exec
UPDATE products 
SET 
    average_cost_price = $2,
    product_price = $2 * (1 + profit_margin_percent / 100),
    product_discounted_price = $2 * (1 + profit_margin_percent / 100) * (1 - discount / 100),
    updated_at = NOW()
WHERE id = $1
`

type UpdateProductAverageCostAndPriceParams struct {
	ID               int32  `json:"id"`
	AverageCostPrice string `json:"averageCostPrice"`
}

func (q *Queries) UpdateProductAverageCostAndPrice(ctx context.Context, arg UpdateProductAverageCostAndPriceParams) error {
	_, err := q.db.ExecContext(ctx, updateProductAverageCostAndPrice, arg.ID, arg.AverageCostPrice)
	return err
}

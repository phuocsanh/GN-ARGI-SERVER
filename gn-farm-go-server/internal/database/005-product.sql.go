// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 005-product.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products WHERE is_published = true
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    product_name,
    product_price,
    product_status,
    product_thumb,
    product_pictures,
    product_videos,
    product_ratings_average,
    product_variations,
    product_description,
    product_slug,
    product_quantity,
    product_type,
    sub_product_type,
    discount,
    product_discounted_price,
    product_selled,
    product_attributes,
    is_draft,
    is_published,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, NOW(), NOW()
) RETURNING id, product_name, product_price, product_status, product_thumb, product_pictures, product_videos, product_ratings_average, product_variations, product_description, product_slug, product_quantity, product_type, sub_product_type, discount, product_discounted_price, product_selled, product_attributes, is_draft, is_published, created_at, updated_at, average_cost_price, profit_margin_percent
`

type CreateProductParams struct {
	ProductName            string                `json:"productName"`
	ProductPrice           string                `json:"productPrice"`
	ProductStatus          sql.NullInt32         `json:"productStatus"`
	ProductThumb           string                `json:"productThumb"`
	ProductPictures        []string              `json:"productPictures"`
	ProductVideos          []string              `json:"productVideos"`
	ProductRatingsAverage  sql.NullString        `json:"productRatingsAverage"`
	ProductVariations      pqtype.NullRawMessage `json:"productVariations"`
	ProductDescription     sql.NullString        `json:"productDescription"`
	ProductSlug            sql.NullString        `json:"productSlug"`
	ProductQuantity        sql.NullInt32         `json:"productQuantity"`
	ProductType            int32                 `json:"productType"`
	SubProductType         []int32               `json:"subProductType"`
	Discount               sql.NullString        `json:"discount"`
	ProductDiscountedPrice string                `json:"productDiscountedPrice"`
	ProductSelled          sql.NullInt32         `json:"productSelled"`
	ProductAttributes      json.RawMessage       `json:"productAttributes"`
	IsDraft                sql.NullBool          `json:"isDraft"`
	IsPublished            sql.NullBool          `json:"isPublished"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.ProductName,
		arg.ProductPrice,
		arg.ProductStatus,
		arg.ProductThumb,
		pq.Array(arg.ProductPictures),
		pq.Array(arg.ProductVideos),
		arg.ProductRatingsAverage,
		arg.ProductVariations,
		arg.ProductDescription,
		arg.ProductSlug,
		arg.ProductQuantity,
		arg.ProductType,
		pq.Array(arg.SubProductType),
		arg.Discount,
		arg.ProductDiscountedPrice,
		arg.ProductSelled,
		arg.ProductAttributes,
		arg.IsDraft,
		arg.IsPublished,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.ProductPrice,
		&i.ProductStatus,
		&i.ProductThumb,
		pq.Array(&i.ProductPictures),
		pq.Array(&i.ProductVideos),
		&i.ProductRatingsAverage,
		&i.ProductVariations,
		&i.ProductDescription,
		&i.ProductSlug,
		&i.ProductQuantity,
		&i.ProductType,
		pq.Array(&i.SubProductType),
		&i.Discount,
		&i.ProductDiscountedPrice,
		&i.ProductSelled,
		&i.ProductAttributes,
		&i.IsDraft,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AverageCostPrice,
		&i.ProfitMarginPercent,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const filterProducts = `-- name: FilterProducts :many
SELECT id, product_name, product_price, product_status, product_thumb, product_pictures, product_videos, product_ratings_average, product_variations, product_description, product_slug, product_quantity, product_type, sub_product_type, discount, product_discounted_price, product_selled, product_attributes, is_draft, is_published, created_at, updated_at, average_cost_price, profit_margin_percent FROM products
WHERE is_published = true
AND (
    CASE
        WHEN $1::integer IS NOT NULL THEN product_type = $1::integer
        ELSE true
    END
)
AND (
    CASE
        WHEN $2::text IS NOT NULL THEN product_price::numeric >= $2::numeric
        ELSE true
    END
)
AND (
    CASE
        WHEN $3::text IS NOT NULL THEN product_price::numeric <= $3::numeric
        ELSE true
    END
)
AND (
    CASE
        WHEN $4::boolean IS NOT NULL THEN
            CASE
                WHEN $4::boolean = true THEN product_quantity > 0
                ELSE product_quantity = 0
            END
        ELSE true
    END
)
ORDER BY
    CASE
        WHEN $5::text = 'price' AND $6::text = 'asc' THEN product_price
    END ASC,
    CASE
        WHEN $5::text = 'price' AND $6::text = 'desc' THEN product_price
    END DESC,
    CASE
        WHEN $5::text = 'name' AND $6::text = 'asc' THEN product_name
    END ASC,
    CASE
        WHEN $5::text = 'name' AND $6::text = 'desc' THEN product_name
    END DESC,
    CASE
        WHEN $5::text = 'created_at' AND $6::text = 'asc' THEN created_at
    END ASC,
    CASE
        WHEN $5::text = 'created_at' AND $6::text = 'desc' THEN created_at
    END DESC,
    CASE
        WHEN $5::text IS NULL THEN created_at
    END DESC
LIMIT $8
OFFSET $7
`

type FilterProductsParams struct {
	Category  sql.NullInt32  `json:"category"`
	MinPrice  sql.NullString `json:"minPrice"`
	MaxPrice  sql.NullString `json:"maxPrice"`
	InStock   sql.NullBool   `json:"inStock"`
	SortBy    sql.NullString `json:"sortBy"`
	SortOrder sql.NullString `json:"sortOrder"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FilterProducts(ctx context.Context, arg FilterProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, filterProducts,
		arg.Category,
		arg.MinPrice,
		arg.MaxPrice,
		arg.InStock,
		arg.SortBy,
		arg.SortOrder,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductStatus,
			&i.ProductThumb,
			pq.Array(&i.ProductPictures),
			pq.Array(&i.ProductVideos),
			&i.ProductRatingsAverage,
			&i.ProductVariations,
			&i.ProductDescription,
			&i.ProductSlug,
			&i.ProductQuantity,
			&i.ProductType,
			pq.Array(&i.SubProductType),
			&i.Discount,
			&i.ProductDiscountedPrice,
			&i.ProductSelled,
			&i.ProductAttributes,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AverageCostPrice,
			&i.ProfitMarginPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one
SELECT id, product_name, product_price, product_status, product_thumb, product_pictures, product_videos, product_ratings_average, product_variations, product_description, product_slug, product_quantity, product_type, sub_product_type, discount, product_discounted_price, product_selled, product_attributes, is_draft, is_published, created_at, updated_at, average_cost_price, profit_margin_percent FROM products WHERE id = $1
`

func (q *Queries) GetProduct(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.ProductPrice,
		&i.ProductStatus,
		&i.ProductThumb,
		pq.Array(&i.ProductPictures),
		pq.Array(&i.ProductVideos),
		&i.ProductRatingsAverage,
		&i.ProductVariations,
		&i.ProductDescription,
		&i.ProductSlug,
		&i.ProductQuantity,
		&i.ProductType,
		pq.Array(&i.SubProductType),
		&i.Discount,
		&i.ProductDiscountedPrice,
		&i.ProductSelled,
		&i.ProductAttributes,
		&i.IsDraft,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AverageCostPrice,
		&i.ProfitMarginPercent,
	)
	return i, err
}

const getProductStats = `-- name: GetProductStats :one
SELECT
    COUNT(*) as total_products,
    COUNT(CASE WHEN product_quantity > 0 THEN 1 END) as in_stock_products,
    COUNT(CASE WHEN product_quantity = 0 THEN 1 END) as out_of_stock_products,
    COALESCE(SUM(product_selled), 0) as total_products_sold,
    COALESCE(AVG(product_ratings_average::numeric), 0) as average_rating,
    COALESCE(MIN(product_price::numeric), 0) as min_price,
    COALESCE(MAX(product_price::numeric), 0) as max_price,
    COALESCE(AVG(product_price::numeric), 0) as avg_price,
    COUNT(DISTINCT product_type) as total_categories
FROM products
WHERE is_published = true
`

type GetProductStatsRow struct {
	TotalProducts      int64       `json:"totalProducts"`
	InStockProducts    int64       `json:"inStockProducts"`
	OutOfStockProducts int64       `json:"outOfStockProducts"`
	TotalProductsSold  interface{} `json:"totalProductsSold"`
	AverageRating      interface{} `json:"averageRating"`
	MinPrice           interface{} `json:"minPrice"`
	MaxPrice           interface{} `json:"maxPrice"`
	AvgPrice           interface{} `json:"avgPrice"`
	TotalCategories    int64       `json:"totalCategories"`
}

func (q *Queries) GetProductStats(ctx context.Context) (GetProductStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getProductStats)
	var i GetProductStatsRow
	err := row.Scan(
		&i.TotalProducts,
		&i.InStockProducts,
		&i.OutOfStockProducts,
		&i.TotalProductsSold,
		&i.AverageRating,
		&i.MinPrice,
		&i.MaxPrice,
		&i.AvgPrice,
		&i.TotalCategories,
	)
	return i, err
}

const listProducts = `-- name: ListProducts :many
SELECT id, product_name, product_price, product_status, product_thumb, product_pictures, product_videos, product_ratings_average, product_variations, product_description, product_slug, product_quantity, product_type, sub_product_type, discount, product_discounted_price, product_selled, product_attributes, is_draft, is_published, created_at, updated_at, average_cost_price, profit_margin_percent FROM products
WHERE is_published = true
ORDER BY created_at DESC
LIMIT CASE WHEN $1 = 0 THEN NULL ELSE $1 END
OFFSET $2
`

type ListProductsParams struct {
	Column1 interface{} `json:"column1"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProducts, arg.Column1, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductStatus,
			&i.ProductThumb,
			pq.Array(&i.ProductPictures),
			pq.Array(&i.ProductVideos),
			&i.ProductRatingsAverage,
			&i.ProductVariations,
			&i.ProductDescription,
			&i.ProductSlug,
			&i.ProductQuantity,
			&i.ProductType,
			pq.Array(&i.SubProductType),
			&i.Discount,
			&i.ProductDiscountedPrice,
			&i.ProductSelled,
			&i.ProductAttributes,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AverageCostPrice,
			&i.ProfitMarginPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsWithFilter = `-- name: ListProductsWithFilter :many
SELECT id, product_name, product_price, product_status, product_thumb, product_pictures, product_videos, product_ratings_average, product_variations, product_description, product_slug, product_quantity, product_type, sub_product_type, discount, product_discounted_price, product_selled, product_attributes, is_draft, is_published, created_at, updated_at, average_cost_price, profit_margin_percent FROM products
WHERE is_published = true
AND (
    CASE
        WHEN $1::integer IS NOT NULL THEN product_type = $1::integer
        ELSE true
    END
)
AND (
    CASE
        WHEN $2::integer IS NOT NULL THEN $2::integer = ANY(sub_product_type)
        ELSE true
    END
)
ORDER BY created_at DESC
LIMIT CASE WHEN $4 = 0 THEN NULL ELSE $4 END
OFFSET $3
`

type ListProductsWithFilterParams struct {
	ProductType    sql.NullInt32 `json:"productType"`
	SubProductType sql.NullInt32 `json:"subProductType"`
	Offset         int32         `json:"offset"`
	Limit          interface{}   `json:"limit"`
}

func (q *Queries) ListProductsWithFilter(ctx context.Context, arg ListProductsWithFilterParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProductsWithFilter,
		arg.ProductType,
		arg.SubProductType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductStatus,
			&i.ProductThumb,
			pq.Array(&i.ProductPictures),
			pq.Array(&i.ProductVideos),
			&i.ProductRatingsAverage,
			&i.ProductVariations,
			&i.ProductDescription,
			&i.ProductSlug,
			&i.ProductQuantity,
			&i.ProductType,
			pq.Array(&i.SubProductType),
			&i.Discount,
			&i.ProductDiscountedPrice,
			&i.ProductSelled,
			&i.ProductAttributes,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AverageCostPrice,
			&i.ProfitMarginPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, product_name, product_price, product_status, product_thumb, product_pictures, product_videos, product_ratings_average, product_variations, product_description, product_slug, product_quantity, product_type, sub_product_type, discount, product_discounted_price, product_selled, product_attributes, is_draft, is_published, created_at, updated_at, average_cost_price, profit_margin_percent FROM products
WHERE is_published = true
AND (
    product_name ILIKE '%' || $1 || '%'
    OR product_description ILIKE '%' || $1 || '%'
)
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type SearchProductsParams struct {
	Column1 sql.NullString `json:"column1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, searchProducts, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductStatus,
			&i.ProductThumb,
			pq.Array(&i.ProductPictures),
			pq.Array(&i.ProductVideos),
			&i.ProductRatingsAverage,
			&i.ProductVariations,
			&i.ProductDescription,
			&i.ProductSlug,
			&i.ProductQuantity,
			&i.ProductType,
			pq.Array(&i.SubProductType),
			&i.Discount,
			&i.ProductDiscountedPrice,
			&i.ProductSelled,
			&i.ProductAttributes,
			&i.IsDraft,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AverageCostPrice,
			&i.ProfitMarginPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    product_name = $2,
    product_price = $3,
    product_status = $4,
    product_thumb = $5,
    product_pictures = $6,
    product_videos = $7,
    product_ratings_average = $8,
    product_variations = $9,
    product_description = $10,
    product_slug = $11,
    product_quantity = $12,
    product_type = $13,
    sub_product_type = $14,
    discount = $15,
    product_discounted_price = $16,
    product_selled = $17,
    product_attributes = $18,
    is_draft = $19,
    is_published = $20,
    updated_at = NOW()
WHERE id = $1
RETURNING id, product_name, product_price, product_status, product_thumb, product_pictures, product_videos, product_ratings_average, product_variations, product_description, product_slug, product_quantity, product_type, sub_product_type, discount, product_discounted_price, product_selled, product_attributes, is_draft, is_published, created_at, updated_at, average_cost_price, profit_margin_percent
`

type UpdateProductParams struct {
	ID                     int32                 `json:"id"`
	ProductName            string                `json:"productName"`
	ProductPrice           string                `json:"productPrice"`
	ProductStatus          sql.NullInt32         `json:"productStatus"`
	ProductThumb           string                `json:"productThumb"`
	ProductPictures        []string              `json:"productPictures"`
	ProductVideos          []string              `json:"productVideos"`
	ProductRatingsAverage  sql.NullString        `json:"productRatingsAverage"`
	ProductVariations      pqtype.NullRawMessage `json:"productVariations"`
	ProductDescription     sql.NullString        `json:"productDescription"`
	ProductSlug            sql.NullString        `json:"productSlug"`
	ProductQuantity        sql.NullInt32         `json:"productQuantity"`
	ProductType            int32                 `json:"productType"`
	SubProductType         []int32               `json:"subProductType"`
	Discount               sql.NullString        `json:"discount"`
	ProductDiscountedPrice string                `json:"productDiscountedPrice"`
	ProductSelled          sql.NullInt32         `json:"productSelled"`
	ProductAttributes      json.RawMessage       `json:"productAttributes"`
	IsDraft                sql.NullBool          `json:"isDraft"`
	IsPublished            sql.NullBool          `json:"isPublished"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.ProductName,
		arg.ProductPrice,
		arg.ProductStatus,
		arg.ProductThumb,
		pq.Array(arg.ProductPictures),
		pq.Array(arg.ProductVideos),
		arg.ProductRatingsAverage,
		arg.ProductVariations,
		arg.ProductDescription,
		arg.ProductSlug,
		arg.ProductQuantity,
		arg.ProductType,
		pq.Array(arg.SubProductType),
		arg.Discount,
		arg.ProductDiscountedPrice,
		arg.ProductSelled,
		arg.ProductAttributes,
		arg.IsDraft,
		arg.IsPublished,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductName,
		&i.ProductPrice,
		&i.ProductStatus,
		&i.ProductThumb,
		pq.Array(&i.ProductPictures),
		pq.Array(&i.ProductVideos),
		&i.ProductRatingsAverage,
		&i.ProductVariations,
		&i.ProductDescription,
		&i.ProductSlug,
		&i.ProductQuantity,
		&i.ProductType,
		pq.Array(&i.SubProductType),
		&i.Discount,
		&i.ProductDiscountedPrice,
		&i.ProductSelled,
		&i.ProductAttributes,
		&i.IsDraft,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AverageCostPrice,
		&i.ProfitMarginPercent,
	)
	return i, err
}

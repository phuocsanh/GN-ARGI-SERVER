// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 010-inventory.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const countInventoryHistoryByProduct = `-- name: CountInventoryHistoryByProduct :one
SELECT COUNT(*) FROM inventory_history WHERE product_id = $1
`

func (q *Queries) CountInventoryHistoryByProduct(ctx context.Context, productID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countInventoryHistoryByProduct, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInventoryReceipts = `-- name: CountInventoryReceipts :one
SELECT COUNT(*) FROM inventory_receipts 
WHERE ($1::text IS NULL OR supplier_name ILIKE '%' || $1 || '%')
  AND ($2::integer IS NULL OR status = $2)
  AND ($3::timestamp IS NULL OR receipt_date >= $3)
  AND ($4::timestamp IS NULL OR receipt_date <= $4)
`

type CountInventoryReceiptsParams struct {
	Column1 string    `json:"column1"`
	Column2 int32     `json:"column2"`
	Column3 time.Time `json:"column3"`
	Column4 time.Time `json:"column4"`
}

func (q *Queries) CountInventoryReceipts(ctx context.Context, arg CountInventoryReceiptsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countInventoryReceipts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInventoryHistory = `-- name: CreateInventoryHistory :one
INSERT INTO inventory_history (
    product_id, receipt_item_id, change_type, quantity_before, 
    quantity_change, quantity_after, unit_price, reason, created_by_user_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, product_id, receipt_item_id, change_type, quantity_before, quantity_change, quantity_after, unit_price, reason, created_by_user_id, created_at
`

type CreateInventoryHistoryParams struct {
	ProductID       int32          `json:"productId"`
	ReceiptItemID   sql.NullInt32  `json:"receiptItemId"`
	ChangeType      string         `json:"changeType"`
	QuantityBefore  int32          `json:"quantityBefore"`
	QuantityChange  int32          `json:"quantityChange"`
	QuantityAfter   int32          `json:"quantityAfter"`
	UnitPrice       sql.NullString `json:"unitPrice"`
	Reason          sql.NullString `json:"reason"`
	CreatedByUserID int32          `json:"createdByUserId"`
}

func (q *Queries) CreateInventoryHistory(ctx context.Context, arg CreateInventoryHistoryParams) (InventoryHistory, error) {
	row := q.db.QueryRowContext(ctx, createInventoryHistory,
		arg.ProductID,
		arg.ReceiptItemID,
		arg.ChangeType,
		arg.QuantityBefore,
		arg.QuantityChange,
		arg.QuantityAfter,
		arg.UnitPrice,
		arg.Reason,
		arg.CreatedByUserID,
	)
	var i InventoryHistory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ReceiptItemID,
		&i.ChangeType,
		&i.QuantityBefore,
		&i.QuantityChange,
		&i.QuantityAfter,
		&i.UnitPrice,
		&i.Reason,
		&i.CreatedByUserID,
		&i.CreatedAt,
	)
	return i, err
}

const createInventoryReceipt = `-- name: CreateInventoryReceipt :one
INSERT INTO inventory_receipts (
    receipt_code, supplier_name, supplier_contact, created_by_user_id, 
    checked_by_user_id, total_amount, total_items, notes, status, receipt_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, receipt_code, supplier_name, supplier_contact, created_by_user_id, checked_by_user_id, total_amount, total_items, notes, status, receipt_date, created_at, updated_at
`

type CreateInventoryReceiptParams struct {
	ReceiptCode     string         `json:"receiptCode"`
	SupplierName    sql.NullString `json:"supplierName"`
	SupplierContact sql.NullString `json:"supplierContact"`
	CreatedByUserID int32          `json:"createdByUserId"`
	CheckedByUserID sql.NullInt32  `json:"checkedByUserId"`
	TotalAmount     string         `json:"totalAmount"`
	TotalItems      int32          `json:"totalItems"`
	Notes           sql.NullString `json:"notes"`
	Status          sql.NullInt32  `json:"status"`
	ReceiptDate     time.Time      `json:"receiptDate"`
}

func (q *Queries) CreateInventoryReceipt(ctx context.Context, arg CreateInventoryReceiptParams) (InventoryReceipt, error) {
	row := q.db.QueryRowContext(ctx, createInventoryReceipt,
		arg.ReceiptCode,
		arg.SupplierName,
		arg.SupplierContact,
		arg.CreatedByUserID,
		arg.CheckedByUserID,
		arg.TotalAmount,
		arg.TotalItems,
		arg.Notes,
		arg.Status,
		arg.ReceiptDate,
	)
	var i InventoryReceipt
	err := row.Scan(
		&i.ID,
		&i.ReceiptCode,
		&i.SupplierName,
		&i.SupplierContact,
		&i.CreatedByUserID,
		&i.CheckedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.Notes,
		&i.Status,
		&i.ReceiptDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInventoryReceiptItem = `-- name: CreateInventoryReceiptItem :one
INSERT INTO inventory_receipt_items (
    receipt_id, product_id, quantity, unit_price, total_price,
    expiry_date, batch_number, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, receipt_id, product_id, quantity, unit_price, total_price, expiry_date, batch_number, notes, created_at, updated_at
`

type CreateInventoryReceiptItemParams struct {
	ReceiptID   int32          `json:"receiptId"`
	ProductID   int32          `json:"productId"`
	Quantity    int32          `json:"quantity"`
	UnitPrice   string         `json:"unitPrice"`
	TotalPrice  string         `json:"totalPrice"`
	ExpiryDate  sql.NullTime   `json:"expiryDate"`
	BatchNumber sql.NullString `json:"batchNumber"`
	Notes       sql.NullString `json:"notes"`
}

func (q *Queries) CreateInventoryReceiptItem(ctx context.Context, arg CreateInventoryReceiptItemParams) (InventoryReceiptItem, error) {
	row := q.db.QueryRowContext(ctx, createInventoryReceiptItem,
		arg.ReceiptID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
		arg.ExpiryDate,
		arg.BatchNumber,
		arg.Notes,
	)
	var i InventoryReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.ExpiryDate,
		&i.BatchNumber,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInventoryReceipt = `-- name: DeleteInventoryReceipt :exec
DELETE FROM inventory_receipts WHERE id = $1
`

func (q *Queries) DeleteInventoryReceipt(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteInventoryReceipt, id)
	return err
}

const deleteInventoryReceiptItem = `-- name: DeleteInventoryReceiptItem :exec
DELETE FROM inventory_receipt_items WHERE id = $1
`

func (q *Queries) DeleteInventoryReceiptItem(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteInventoryReceiptItem, id)
	return err
}

const getInventoryHistoryByProduct = `-- name: GetInventoryHistoryByProduct :many
SELECT id, product_id, receipt_item_id, change_type, quantity_before, quantity_change, quantity_after, unit_price, reason, created_by_user_id, created_at FROM inventory_history 
WHERE product_id = $1 
ORDER BY created_at DESC, id DESC
LIMIT $2 OFFSET $3
`

type GetInventoryHistoryByProductParams struct {
	ProductID int32 `json:"productId"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetInventoryHistoryByProduct(ctx context.Context, arg GetInventoryHistoryByProductParams) ([]InventoryHistory, error) {
	rows, err := q.db.QueryContext(ctx, getInventoryHistoryByProduct, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryHistory
	for rows.Next() {
		var i InventoryHistory
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ReceiptItemID,
			&i.ChangeType,
			&i.QuantityBefore,
			&i.QuantityChange,
			&i.QuantityAfter,
			&i.UnitPrice,
			&i.Reason,
			&i.CreatedByUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryReceipt = `-- name: GetInventoryReceipt :one
SELECT id, receipt_code, supplier_name, supplier_contact, created_by_user_id, checked_by_user_id, total_amount, total_items, notes, status, receipt_date, created_at, updated_at FROM inventory_receipts WHERE id = $1
`

func (q *Queries) GetInventoryReceipt(ctx context.Context, id int32) (InventoryReceipt, error) {
	row := q.db.QueryRowContext(ctx, getInventoryReceipt, id)
	var i InventoryReceipt
	err := row.Scan(
		&i.ID,
		&i.ReceiptCode,
		&i.SupplierName,
		&i.SupplierContact,
		&i.CreatedByUserID,
		&i.CheckedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.Notes,
		&i.Status,
		&i.ReceiptDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryReceiptByCode = `-- name: GetInventoryReceiptByCode :one
SELECT id, receipt_code, supplier_name, supplier_contact, created_by_user_id, checked_by_user_id, total_amount, total_items, notes, status, receipt_date, created_at, updated_at FROM inventory_receipts WHERE receipt_code = $1
`

func (q *Queries) GetInventoryReceiptByCode(ctx context.Context, receiptCode string) (InventoryReceipt, error) {
	row := q.db.QueryRowContext(ctx, getInventoryReceiptByCode, receiptCode)
	var i InventoryReceipt
	err := row.Scan(
		&i.ID,
		&i.ReceiptCode,
		&i.SupplierName,
		&i.SupplierContact,
		&i.CreatedByUserID,
		&i.CheckedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.Notes,
		&i.Status,
		&i.ReceiptDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryReceiptItem = `-- name: GetInventoryReceiptItem :one
SELECT id, receipt_id, product_id, quantity, unit_price, total_price, expiry_date, batch_number, notes, created_at, updated_at FROM inventory_receipt_items WHERE id = $1
`

func (q *Queries) GetInventoryReceiptItem(ctx context.Context, id int32) (InventoryReceiptItem, error) {
	row := q.db.QueryRowContext(ctx, getInventoryReceiptItem, id)
	var i InventoryReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.ExpiryDate,
		&i.BatchNumber,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryReceiptItems = `-- name: GetInventoryReceiptItems :many
SELECT id, receipt_id, product_id, quantity, unit_price, total_price, expiry_date, batch_number, notes, created_at, updated_at FROM inventory_receipt_items WHERE receipt_id = $1 ORDER BY id
`

func (q *Queries) GetInventoryReceiptItems(ctx context.Context, receiptID int32) ([]InventoryReceiptItem, error) {
	rows, err := q.db.QueryContext(ctx, getInventoryReceiptItems, receiptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryReceiptItem
	for rows.Next() {
		var i InventoryReceiptItem
		if err := rows.Scan(
			&i.ID,
			&i.ReceiptID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.ExpiryDate,
			&i.BatchNumber,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryReceipts = `-- name: ListInventoryReceipts :many
SELECT id, receipt_code, supplier_name, supplier_contact, created_by_user_id, checked_by_user_id, total_amount, total_items, notes, status, receipt_date, created_at, updated_at FROM inventory_receipts 
WHERE ($1::text IS NULL OR supplier_name ILIKE '%' || $1 || '%')
  AND ($2::integer IS NULL OR status = $2)
  AND ($3::timestamp IS NULL OR receipt_date >= $3)
  AND ($4::timestamp IS NULL OR receipt_date <= $4)
ORDER BY receipt_date DESC, id DESC
LIMIT $5 OFFSET $6
`

type ListInventoryReceiptsParams struct {
	Column1 string    `json:"column1"`
	Column2 int32     `json:"column2"`
	Column3 time.Time `json:"column3"`
	Column4 time.Time `json:"column4"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListInventoryReceipts(ctx context.Context, arg ListInventoryReceiptsParams) ([]InventoryReceipt, error) {
	rows, err := q.db.QueryContext(ctx, listInventoryReceipts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InventoryReceipt
	for rows.Next() {
		var i InventoryReceipt
		if err := rows.Scan(
			&i.ID,
			&i.ReceiptCode,
			&i.SupplierName,
			&i.SupplierContact,
			&i.CreatedByUserID,
			&i.CheckedByUserID,
			&i.TotalAmount,
			&i.TotalItems,
			&i.Notes,
			&i.Status,
			&i.ReceiptDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryReceipt = `-- name: UpdateInventoryReceipt :one
UPDATE inventory_receipts 
SET supplier_name = $2, supplier_contact = $3, checked_by_user_id = $4,
    total_amount = $5, total_items = $6, notes = $7, status = $8, updated_at = NOW()
WHERE id = $1 
RETURNING id, receipt_code, supplier_name, supplier_contact, created_by_user_id, checked_by_user_id, total_amount, total_items, notes, status, receipt_date, created_at, updated_at
`

type UpdateInventoryReceiptParams struct {
	ID              int32          `json:"id"`
	SupplierName    sql.NullString `json:"supplierName"`
	SupplierContact sql.NullString `json:"supplierContact"`
	CheckedByUserID sql.NullInt32  `json:"checkedByUserId"`
	TotalAmount     string         `json:"totalAmount"`
	TotalItems      int32          `json:"totalItems"`
	Notes           sql.NullString `json:"notes"`
	Status          sql.NullInt32  `json:"status"`
}

func (q *Queries) UpdateInventoryReceipt(ctx context.Context, arg UpdateInventoryReceiptParams) (InventoryReceipt, error) {
	row := q.db.QueryRowContext(ctx, updateInventoryReceipt,
		arg.ID,
		arg.SupplierName,
		arg.SupplierContact,
		arg.CheckedByUserID,
		arg.TotalAmount,
		arg.TotalItems,
		arg.Notes,
		arg.Status,
	)
	var i InventoryReceipt
	err := row.Scan(
		&i.ID,
		&i.ReceiptCode,
		&i.SupplierName,
		&i.SupplierContact,
		&i.CreatedByUserID,
		&i.CheckedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.Notes,
		&i.Status,
		&i.ReceiptDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInventoryReceiptItem = `-- name: UpdateInventoryReceiptItem :one
UPDATE inventory_receipt_items 
SET quantity = $2, unit_price = $3, total_price = $4,
    expiry_date = $5, batch_number = $6, notes = $7, updated_at = NOW()
WHERE id = $1 
RETURNING id, receipt_id, product_id, quantity, unit_price, total_price, expiry_date, batch_number, notes, created_at, updated_at
`

type UpdateInventoryReceiptItemParams struct {
	ID          int32          `json:"id"`
	Quantity    int32          `json:"quantity"`
	UnitPrice   string         `json:"unitPrice"`
	TotalPrice  string         `json:"totalPrice"`
	ExpiryDate  sql.NullTime   `json:"expiryDate"`
	BatchNumber sql.NullString `json:"batchNumber"`
	Notes       sql.NullString `json:"notes"`
}

func (q *Queries) UpdateInventoryReceiptItem(ctx context.Context, arg UpdateInventoryReceiptItemParams) (InventoryReceiptItem, error) {
	row := q.db.QueryRowContext(ctx, updateInventoryReceiptItem,
		arg.ID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
		arg.ExpiryDate,
		arg.BatchNumber,
		arg.Notes,
	)
	var i InventoryReceiptItem
	err := row.Scan(
		&i.ID,
		&i.ReceiptID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.ExpiryDate,
		&i.BatchNumber,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductQuantity = `-- name: UpdateProductQuantity :exec
UPDATE products SET product_quantity = $2, updated_at = NOW() WHERE id = $1
`

type UpdateProductQuantityParams struct {
	ID              int32         `json:"id"`
	ProductQuantity sql.NullInt32 `json:"productQuantity"`
}

func (q *Queries) UpdateProductQuantity(ctx context.Context, arg UpdateProductQuantityParams) error {
	_, err := q.db.ExecContext(ctx, updateProductQuantity, arg.ID, arg.ProductQuantity)
	return err
}

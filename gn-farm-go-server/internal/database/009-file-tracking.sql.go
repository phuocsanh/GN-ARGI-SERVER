// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 009-file-tracking.sql

package database

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const countActiveReferences = `-- name: CountActiveReferences :one
SELECT COUNT(*) FROM file_references 
WHERE file_id = $1 AND reference_type = 'active' AND deleted_at IS NULL
`

func (q *Queries) CountActiveReferences(ctx context.Context, fileID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveReferences, fileID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCleanupJob = `-- name: CreateCleanupJob :one
INSERT INTO file_cleanup_jobs (
    job_type, status, parameters
) VALUES (
    $1, $2, $3
) RETURNING id, job_type, status, parameters, files_processed, files_deleted, files_failed, error_message, started_at, completed_at, created_at
`

type CreateCleanupJobParams struct {
	JobType    string                `json:"jobType"`
	Status     sql.NullString        `json:"status"`
	Parameters pqtype.NullRawMessage `json:"parameters"`
}

func (q *Queries) CreateCleanupJob(ctx context.Context, arg CreateCleanupJobParams) (FileCleanupJob, error) {
	row := q.db.QueryRowContext(ctx, createCleanupJob, arg.JobType, arg.Status, arg.Parameters)
	var i FileCleanupJob
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Status,
		&i.Parameters,
		&i.FilesProcessed,
		&i.FilesDeleted,
		&i.FilesFailed,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createFileAuditLog = `-- name: CreateFileAuditLog :one
INSERT INTO file_audit_logs (
    file_id, action, entity_type, entity_id, old_reference_count, new_reference_count,
    details, performed_by_user_id, ip_address, user_agent
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, file_id, action, entity_type, entity_id, old_reference_count, new_reference_count, details, performed_by_user_id, performed_at, ip_address, user_agent
`

type CreateFileAuditLogParams struct {
	FileID            sql.NullInt32         `json:"fileId"`
	Action            string                `json:"action"`
	EntityType        sql.NullString        `json:"entityType"`
	EntityID          sql.NullInt32         `json:"entityId"`
	OldReferenceCount sql.NullInt32         `json:"oldReferenceCount"`
	NewReferenceCount sql.NullInt32         `json:"newReferenceCount"`
	Details           pqtype.NullRawMessage `json:"details"`
	PerformedByUserID sql.NullInt32         `json:"performedByUserId"`
	IpAddress         pqtype.Inet           `json:"ipAddress"`
	UserAgent         sql.NullString        `json:"userAgent"`
}

func (q *Queries) CreateFileAuditLog(ctx context.Context, arg CreateFileAuditLogParams) (FileAuditLog, error) {
	row := q.db.QueryRowContext(ctx, createFileAuditLog,
		arg.FileID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.OldReferenceCount,
		arg.NewReferenceCount,
		arg.Details,
		arg.PerformedByUserID,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i FileAuditLog
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.OldReferenceCount,
		&i.NewReferenceCount,
		&i.Details,
		&i.PerformedByUserID,
		&i.PerformedAt,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const createFileReference = `-- name: CreateFileReference :one
INSERT INTO file_references (
    file_id, entity_type, entity_id, field_name, reference_type, created_by_user_id
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, file_id, entity_type, entity_id, field_name, reference_type, created_at, created_by_user_id, deleted_at, deleted_by_user_id
`

type CreateFileReferenceParams struct {
	FileID          int32          `json:"fileId"`
	EntityType      string         `json:"entityType"`
	EntityID        int32          `json:"entityId"`
	FieldName       sql.NullString `json:"fieldName"`
	ReferenceType   sql.NullString `json:"referenceType"`
	CreatedByUserID sql.NullInt32  `json:"createdByUserId"`
}

func (q *Queries) CreateFileReference(ctx context.Context, arg CreateFileReferenceParams) (FileReference, error) {
	row := q.db.QueryRowContext(ctx, createFileReference,
		arg.FileID,
		arg.EntityType,
		arg.EntityID,
		arg.FieldName,
		arg.ReferenceType,
		arg.CreatedByUserID,
	)
	var i FileReference
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.EntityType,
		&i.EntityID,
		&i.FieldName,
		&i.ReferenceType,
		&i.CreatedAt,
		&i.CreatedByUserID,
		&i.DeletedAt,
		&i.DeletedByUserID,
	)
	return i, err
}

const createFileUpload = `-- name: CreateFileUpload :one
INSERT INTO file_uploads (
    public_id, file_url, file_name, file_type, file_size, folder, mime_type,
    uploaded_by_user_id, tags, metadata, is_temporary
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, public_id, file_url, file_name, file_type, file_size, folder, mime_type, reference_count, is_temporary, is_orphaned, uploaded_by_user_id, tags, metadata, created_at, updated_at, marked_for_deletion_at, deleted_at
`

type CreateFileUploadParams struct {
	PublicID         string                `json:"publicId"`
	FileUrl          string                `json:"fileUrl"`
	FileName         string                `json:"fileName"`
	FileType         string                `json:"fileType"`
	FileSize         int64                 `json:"fileSize"`
	Folder           sql.NullString        `json:"folder"`
	MimeType         sql.NullString        `json:"mimeType"`
	UploadedByUserID sql.NullInt32         `json:"uploadedByUserId"`
	Tags             []string              `json:"tags"`
	Metadata         pqtype.NullRawMessage `json:"metadata"`
	IsTemporary      sql.NullBool          `json:"isTemporary"`
}

func (q *Queries) CreateFileUpload(ctx context.Context, arg CreateFileUploadParams) (FileUpload, error) {
	row := q.db.QueryRowContext(ctx, createFileUpload,
		arg.PublicID,
		arg.FileUrl,
		arg.FileName,
		arg.FileType,
		arg.FileSize,
		arg.Folder,
		arg.MimeType,
		arg.UploadedByUserID,
		pq.Array(arg.Tags),
		arg.Metadata,
		arg.IsTemporary,
	)
	var i FileUpload
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.FileUrl,
		&i.FileName,
		&i.FileType,
		&i.FileSize,
		&i.Folder,
		&i.MimeType,
		&i.ReferenceCount,
		&i.IsTemporary,
		&i.IsOrphaned,
		&i.UploadedByUserID,
		pq.Array(&i.Tags),
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MarkedForDeletionAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteFileReference = `-- name: DeleteFileReference :exec
UPDATE file_references 
SET deleted_at = CURRENT_TIMESTAMP, deleted_by_user_id = $4
WHERE file_id = $1 AND entity_type = $2 AND entity_id = $3
`

type DeleteFileReferenceParams struct {
	FileID          int32         `json:"fileId"`
	EntityType      string        `json:"entityType"`
	EntityID        int32         `json:"entityId"`
	DeletedByUserID sql.NullInt32 `json:"deletedByUserId"`
}

func (q *Queries) DeleteFileReference(ctx context.Context, arg DeleteFileReferenceParams) error {
	_, err := q.db.ExecContext(ctx, deleteFileReference,
		arg.FileID,
		arg.EntityType,
		arg.EntityID,
		arg.DeletedByUserID,
	)
	return err
}

const deleteFileUpload = `-- name: DeleteFileUpload :exec
UPDATE file_uploads 
SET deleted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteFileUpload(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteFileUpload, id)
	return err
}

const getCleanupJob = `-- name: GetCleanupJob :one
SELECT id, job_type, status, parameters, files_processed, files_deleted, files_failed, error_message, started_at, completed_at, created_at FROM file_cleanup_jobs WHERE id = $1
`

func (q *Queries) GetCleanupJob(ctx context.Context, id int32) (FileCleanupJob, error) {
	row := q.db.QueryRowContext(ctx, getCleanupJob, id)
	var i FileCleanupJob
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Status,
		&i.Parameters,
		&i.FilesProcessed,
		&i.FilesDeleted,
		&i.FilesFailed,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getCleanupJobs = `-- name: GetCleanupJobs :many
SELECT id, job_type, status, parameters, files_processed, files_deleted, files_failed, error_message, started_at, completed_at, created_at FROM file_cleanup_jobs 
WHERE ($1::text IS NULL OR job_type = $1)
  AND ($2::text IS NULL OR status = $2)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetCleanupJobsParams struct {
	Column1 string `json:"column1"`
	Column2 string `json:"column2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) GetCleanupJobs(ctx context.Context, arg GetCleanupJobsParams) ([]FileCleanupJob, error) {
	rows, err := q.db.QueryContext(ctx, getCleanupJobs,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileCleanupJob
	for rows.Next() {
		var i FileCleanupJob
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Status,
			&i.Parameters,
			&i.FilesProcessed,
			&i.FilesDeleted,
			&i.FilesFailed,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileAuditLogs = `-- name: GetFileAuditLogs :many
SELECT fal.id, fal.file_id, fal.action, fal.entity_type, fal.entity_id, fal.old_reference_count, fal.new_reference_count, fal.details, fal.performed_by_user_id, fal.performed_at, fal.ip_address, fal.user_agent, fu.public_id, fu.file_name
FROM file_audit_logs fal
LEFT JOIN file_uploads fu ON fal.file_id = fu.id
WHERE ($1::integer IS NULL OR fal.file_id = $1)
  AND ($2::text IS NULL OR fal.action = $2)
  AND ($3::integer IS NULL OR fal.performed_by_user_id = $3)
  AND fal.performed_at >= $4
  AND fal.performed_at <= $5
ORDER BY fal.performed_at DESC
LIMIT $6 OFFSET $7
`

type GetFileAuditLogsParams struct {
	Column1       int32        `json:"column1"`
	Column2       string       `json:"column2"`
	Column3       int32        `json:"column3"`
	PerformedAt   sql.NullTime `json:"performedAt"`
	PerformedAt_2 sql.NullTime `json:"performedAt2"`
	Limit         int32        `json:"limit"`
	Offset        int32        `json:"offset"`
}

type GetFileAuditLogsRow struct {
	ID                int32                 `json:"id"`
	FileID            sql.NullInt32         `json:"fileId"`
	Action            string                `json:"action"`
	EntityType        sql.NullString        `json:"entityType"`
	EntityID          sql.NullInt32         `json:"entityId"`
	OldReferenceCount sql.NullInt32         `json:"oldReferenceCount"`
	NewReferenceCount sql.NullInt32         `json:"newReferenceCount"`
	Details           pqtype.NullRawMessage `json:"details"`
	PerformedByUserID sql.NullInt32         `json:"performedByUserId"`
	PerformedAt       sql.NullTime          `json:"performedAt"`
	IpAddress         pqtype.Inet           `json:"ipAddress"`
	UserAgent         sql.NullString        `json:"userAgent"`
	PublicID          sql.NullString        `json:"publicId"`
	FileName          sql.NullString        `json:"fileName"`
}

func (q *Queries) GetFileAuditLogs(ctx context.Context, arg GetFileAuditLogsParams) ([]GetFileAuditLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFileAuditLogs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.PerformedAt,
		arg.PerformedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFileAuditLogsRow
	for rows.Next() {
		var i GetFileAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldReferenceCount,
			&i.NewReferenceCount,
			&i.Details,
			&i.PerformedByUserID,
			&i.PerformedAt,
			&i.IpAddress,
			&i.UserAgent,
			&i.PublicID,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileReferences = `-- name: GetFileReferences :many
SELECT fr.id, fr.file_id, fr.entity_type, fr.entity_id, fr.field_name, fr.reference_type, fr.created_at, fr.created_by_user_id, fr.deleted_at, fr.deleted_by_user_id, fu.public_id, fu.file_url, fu.file_name
FROM file_references fr
JOIN file_uploads fu ON fr.file_id = fu.id
WHERE fr.entity_type = $1 AND fr.entity_id = $2 AND fr.deleted_at IS NULL
ORDER BY fr.created_at ASC
`

type GetFileReferencesParams struct {
	EntityType string `json:"entityType"`
	EntityID   int32  `json:"entityId"`
}

type GetFileReferencesRow struct {
	ID              int32          `json:"id"`
	FileID          int32          `json:"fileId"`
	EntityType      string         `json:"entityType"`
	EntityID        int32          `json:"entityId"`
	FieldName       sql.NullString `json:"fieldName"`
	ReferenceType   sql.NullString `json:"referenceType"`
	CreatedAt       sql.NullTime   `json:"createdAt"`
	CreatedByUserID sql.NullInt32  `json:"createdByUserId"`
	DeletedAt       sql.NullTime   `json:"deletedAt"`
	DeletedByUserID sql.NullInt32  `json:"deletedByUserId"`
	PublicID        string         `json:"publicId"`
	FileUrl         string         `json:"fileUrl"`
	FileName        string         `json:"fileName"`
}

func (q *Queries) GetFileReferences(ctx context.Context, arg GetFileReferencesParams) ([]GetFileReferencesRow, error) {
	rows, err := q.db.QueryContext(ctx, getFileReferences, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFileReferencesRow
	for rows.Next() {
		var i GetFileReferencesRow
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.EntityType,
			&i.EntityID,
			&i.FieldName,
			&i.ReferenceType,
			&i.CreatedAt,
			&i.CreatedByUserID,
			&i.DeletedAt,
			&i.DeletedByUserID,
			&i.PublicID,
			&i.FileUrl,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileReferencesByFileID = `-- name: GetFileReferencesByFileID :many
SELECT id, file_id, entity_type, entity_id, field_name, reference_type, created_at, created_by_user_id, deleted_at, deleted_by_user_id FROM file_references 
WHERE file_id = $1 AND deleted_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) GetFileReferencesByFileID(ctx context.Context, fileID int32) ([]FileReference, error) {
	rows, err := q.db.QueryContext(ctx, getFileReferencesByFileID, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileReference
	for rows.Next() {
		var i FileReference
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.EntityType,
			&i.EntityID,
			&i.FieldName,
			&i.ReferenceType,
			&i.CreatedAt,
			&i.CreatedByUserID,
			&i.DeletedAt,
			&i.DeletedByUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileStatistics = `-- name: GetFileStatistics :one
SELECT 
    COUNT(*) as total_files,
    COUNT(*) FILTER (WHERE is_temporary = TRUE) as temporary_files,
    COUNT(*) FILTER (WHERE is_orphaned = TRUE) as orphaned_files,
    COUNT(*) FILTER (WHERE reference_count = 0) as zero_reference_files,
    COUNT(*) FILTER (WHERE deleted_at IS NOT NULL) as deleted_files,
    SUM(file_size) as total_size,
    SUM(file_size) FILTER (WHERE is_orphaned = TRUE) as orphaned_size
FROM file_uploads
`

type GetFileStatisticsRow struct {
	TotalFiles         int64 `json:"totalFiles"`
	TemporaryFiles     int64 `json:"temporaryFiles"`
	OrphanedFiles      int64 `json:"orphanedFiles"`
	ZeroReferenceFiles int64 `json:"zeroReferenceFiles"`
	DeletedFiles       int64 `json:"deletedFiles"`
	TotalSize          int64 `json:"totalSize"`
	OrphanedSize       int64 `json:"orphanedSize"`
}

func (q *Queries) GetFileStatistics(ctx context.Context) (GetFileStatisticsRow, error) {
	row := q.db.QueryRowContext(ctx, getFileStatistics)
	var i GetFileStatisticsRow
	err := row.Scan(
		&i.TotalFiles,
		&i.TemporaryFiles,
		&i.OrphanedFiles,
		&i.ZeroReferenceFiles,
		&i.DeletedFiles,
		&i.TotalSize,
		&i.OrphanedSize,
	)
	return i, err
}

const getFileUploadByID = `-- name: GetFileUploadByID :one
SELECT id, public_id, file_url, file_name, file_type, file_size, folder, mime_type, reference_count, is_temporary, is_orphaned, uploaded_by_user_id, tags, metadata, created_at, updated_at, marked_for_deletion_at, deleted_at FROM file_uploads WHERE id = $1
`

func (q *Queries) GetFileUploadByID(ctx context.Context, id int32) (FileUpload, error) {
	row := q.db.QueryRowContext(ctx, getFileUploadByID, id)
	var i FileUpload
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.FileUrl,
		&i.FileName,
		&i.FileType,
		&i.FileSize,
		&i.Folder,
		&i.MimeType,
		&i.ReferenceCount,
		&i.IsTemporary,
		&i.IsOrphaned,
		&i.UploadedByUserID,
		pq.Array(&i.Tags),
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MarkedForDeletionAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFileUploadByPublicID = `-- name: GetFileUploadByPublicID :one
SELECT id, public_id, file_url, file_name, file_type, file_size, folder, mime_type, reference_count, is_temporary, is_orphaned, uploaded_by_user_id, tags, metadata, created_at, updated_at, marked_for_deletion_at, deleted_at FROM file_uploads WHERE public_id = $1
`

func (q *Queries) GetFileUploadByPublicID(ctx context.Context, publicID string) (FileUpload, error) {
	row := q.db.QueryRowContext(ctx, getFileUploadByPublicID, publicID)
	var i FileUpload
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.FileUrl,
		&i.FileName,
		&i.FileType,
		&i.FileSize,
		&i.Folder,
		&i.MimeType,
		&i.ReferenceCount,
		&i.IsTemporary,
		&i.IsOrphaned,
		&i.UploadedByUserID,
		pq.Array(&i.Tags),
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MarkedForDeletionAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFilesByType = `-- name: GetFilesByType :many
SELECT file_type, COUNT(*) as count, SUM(file_size) as total_size
FROM file_uploads 
WHERE deleted_at IS NULL
GROUP BY file_type
ORDER BY count DESC
`

type GetFilesByTypeRow struct {
	FileType  string `json:"fileType"`
	Count     int64  `json:"count"`
	TotalSize int64  `json:"totalSize"`
}

func (q *Queries) GetFilesByType(ctx context.Context) ([]GetFilesByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilesByType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilesByTypeRow
	for rows.Next() {
		var i GetFilesByTypeRow
		if err := rows.Scan(&i.FileType, &i.Count, &i.TotalSize); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByUser = `-- name: GetFilesByUser :many
SELECT id, public_id, file_url, file_name, file_type, file_size, folder, mime_type, reference_count, is_temporary, is_orphaned, uploaded_by_user_id, tags, metadata, created_at, updated_at, marked_for_deletion_at, deleted_at FROM file_uploads 
WHERE uploaded_by_user_id = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetFilesByUserParams struct {
	UploadedByUserID sql.NullInt32 `json:"uploadedByUserId"`
	Limit            int32         `json:"limit"`
	Offset           int32         `json:"offset"`
}

func (q *Queries) GetFilesByUser(ctx context.Context, arg GetFilesByUserParams) ([]FileUpload, error) {
	rows, err := q.db.QueryContext(ctx, getFilesByUser, arg.UploadedByUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileUpload
	for rows.Next() {
		var i FileUpload
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.FileUrl,
			&i.FileName,
			&i.FileType,
			&i.FileSize,
			&i.Folder,
			&i.MimeType,
			&i.ReferenceCount,
			&i.IsTemporary,
			&i.IsOrphaned,
			&i.UploadedByUserID,
			pq.Array(&i.Tags),
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MarkedForDeletionAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesMarkedForDeletion = `-- name: GetFilesMarkedForDeletion :many
SELECT id, public_id, file_url, file_name, file_type, file_size, folder, mime_type, reference_count, is_temporary, is_orphaned, uploaded_by_user_id, tags, metadata, created_at, updated_at, marked_for_deletion_at, deleted_at FROM file_uploads 
WHERE marked_for_deletion_at IS NOT NULL 
  AND marked_for_deletion_at < NOW() - INTERVAL '7 days'
  AND deleted_at IS NULL
ORDER BY marked_for_deletion_at ASC
LIMIT $1
`

func (q *Queries) GetFilesMarkedForDeletion(ctx context.Context, limit int32) ([]FileUpload, error) {
	rows, err := q.db.QueryContext(ctx, getFilesMarkedForDeletion, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileUpload
	for rows.Next() {
		var i FileUpload
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.FileUrl,
			&i.FileName,
			&i.FileType,
			&i.FileSize,
			&i.Folder,
			&i.MimeType,
			&i.ReferenceCount,
			&i.IsTemporary,
			&i.IsOrphaned,
			&i.UploadedByUserID,
			pq.Array(&i.Tags),
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MarkedForDeletionAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOldestTemporaryFiles = `-- name: GetOldestTemporaryFiles :many
SELECT id, public_id, file_url, file_name, file_type, file_size, folder, mime_type, reference_count, is_temporary, is_orphaned, uploaded_by_user_id, tags, metadata, created_at, updated_at, marked_for_deletion_at, deleted_at FROM file_uploads 
WHERE is_temporary = TRUE 
  AND created_at < NOW() - INTERVAL '1 hour'
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetOldestTemporaryFiles(ctx context.Context, limit int32) ([]FileUpload, error) {
	rows, err := q.db.QueryContext(ctx, getOldestTemporaryFiles, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileUpload
	for rows.Next() {
		var i FileUpload
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.FileUrl,
			&i.FileName,
			&i.FileType,
			&i.FileSize,
			&i.Folder,
			&i.MimeType,
			&i.ReferenceCount,
			&i.IsTemporary,
			&i.IsOrphaned,
			&i.UploadedByUserID,
			pq.Array(&i.Tags),
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MarkedForDeletionAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedFiles = `-- name: GetOrphanedFiles :many
SELECT id, public_id, file_url, file_name, file_type, file_size, folder, mime_type, reference_count, is_temporary, is_orphaned, uploaded_by_user_id, tags, metadata, created_at, updated_at, marked_for_deletion_at, deleted_at FROM file_uploads 
WHERE is_orphaned = TRUE 
  AND marked_for_deletion_at IS NOT NULL
  AND marked_for_deletion_at < $1
ORDER BY marked_for_deletion_at ASC
LIMIT $2
`

type GetOrphanedFilesParams struct {
	MarkedForDeletionAt sql.NullTime `json:"markedForDeletionAt"`
	Limit               int32        `json:"limit"`
}

func (q *Queries) GetOrphanedFiles(ctx context.Context, arg GetOrphanedFilesParams) ([]FileUpload, error) {
	rows, err := q.db.QueryContext(ctx, getOrphanedFiles, arg.MarkedForDeletionAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileUpload
	for rows.Next() {
		var i FileUpload
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.FileUrl,
			&i.FileName,
			&i.FileType,
			&i.FileSize,
			&i.Folder,
			&i.MimeType,
			&i.ReferenceCount,
			&i.IsTemporary,
			&i.IsOrphaned,
			&i.UploadedByUserID,
			pq.Array(&i.Tags),
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MarkedForDeletionAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRunningCleanupJobs = `-- name: GetRunningCleanupJobs :many
SELECT id, job_type, status, parameters, files_processed, files_deleted, files_failed, error_message, started_at, completed_at, created_at FROM file_cleanup_jobs 
WHERE status = 'running'
ORDER BY started_at ASC
`

func (q *Queries) GetRunningCleanupJobs(ctx context.Context) ([]FileCleanupJob, error) {
	rows, err := q.db.QueryContext(ctx, getRunningCleanupJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileCleanupJob
	for rows.Next() {
		var i FileCleanupJob
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Status,
			&i.Parameters,
			&i.FilesProcessed,
			&i.FilesDeleted,
			&i.FilesFailed,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemporaryFiles = `-- name: GetTemporaryFiles :many
SELECT id, public_id, file_url, file_name, file_type, file_size, folder, mime_type, reference_count, is_temporary, is_orphaned, uploaded_by_user_id, tags, metadata, created_at, updated_at, marked_for_deletion_at, deleted_at FROM file_uploads 
WHERE is_temporary = TRUE 
  AND created_at < $1
ORDER BY created_at ASC
LIMIT $2
`

type GetTemporaryFilesParams struct {
	CreatedAt sql.NullTime `json:"createdAt"`
	Limit     int32        `json:"limit"`
}

func (q *Queries) GetTemporaryFiles(ctx context.Context, arg GetTemporaryFilesParams) ([]FileUpload, error) {
	rows, err := q.db.QueryContext(ctx, getTemporaryFiles, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileUpload
	for rows.Next() {
		var i FileUpload
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.FileUrl,
			&i.FileName,
			&i.FileType,
			&i.FileSize,
			&i.Folder,
			&i.MimeType,
			&i.ReferenceCount,
			&i.IsTemporary,
			&i.IsOrphaned,
			&i.UploadedByUserID,
			pq.Array(&i.Tags),
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MarkedForDeletionAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteFileReference = `-- name: HardDeleteFileReference :exec
DELETE FROM file_references 
WHERE file_id = $1 AND entity_type = $2 AND entity_id = $3
`

type HardDeleteFileReferenceParams struct {
	FileID     int32  `json:"fileId"`
	EntityType string `json:"entityType"`
	EntityID   int32  `json:"entityId"`
}

func (q *Queries) HardDeleteFileReference(ctx context.Context, arg HardDeleteFileReferenceParams) error {
	_, err := q.db.ExecContext(ctx, hardDeleteFileReference, arg.FileID, arg.EntityType, arg.EntityID)
	return err
}

const hardDeleteFileUpload = `-- name: HardDeleteFileUpload :exec
DELETE FROM file_uploads WHERE id = $1
`

func (q *Queries) HardDeleteFileUpload(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, hardDeleteFileUpload, id)
	return err
}

const markFileForDeletion = `-- name: MarkFileForDeletion :exec
UPDATE file_uploads 
SET is_orphaned = TRUE, marked_for_deletion_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) MarkFileForDeletion(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markFileForDeletion, id)
	return err
}

const searchFiles = `-- name: SearchFiles :many
SELECT id, public_id, file_url, file_name, file_type, file_size, folder, mime_type, reference_count, is_temporary, is_orphaned, uploaded_by_user_id, tags, metadata, created_at, updated_at, marked_for_deletion_at, deleted_at FROM file_uploads 
WHERE deleted_at IS NULL
  AND ($1::text IS NULL OR file_name ILIKE '%' || $1 || '%')
  AND ($2::text IS NULL OR file_type = $2)
  AND ($3::integer IS NULL OR uploaded_by_user_id = $3)
  AND ($4::boolean IS NULL OR is_temporary = $4)
  AND ($5::boolean IS NULL OR is_orphaned = $5)
ORDER BY created_at DESC
LIMIT $6 OFFSET $7
`

type SearchFilesParams struct {
	Column1 string `json:"column1"`
	Column2 string `json:"column2"`
	Column3 int32  `json:"column3"`
	Column4 bool   `json:"column4"`
	Column5 bool   `json:"column5"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) SearchFiles(ctx context.Context, arg SearchFilesParams) ([]FileUpload, error) {
	rows, err := q.db.QueryContext(ctx, searchFiles,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FileUpload
	for rows.Next() {
		var i FileUpload
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.FileUrl,
			&i.FileName,
			&i.FileType,
			&i.FileSize,
			&i.Folder,
			&i.MimeType,
			&i.ReferenceCount,
			&i.IsTemporary,
			&i.IsOrphaned,
			&i.UploadedByUserID,
			pq.Array(&i.Tags),
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MarkedForDeletionAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCleanupJobStatus = `-- name: UpdateCleanupJobStatus :exec
UPDATE file_cleanup_jobs 
SET status = $2,
    files_processed = COALESCE($3, files_processed),
    files_deleted = COALESCE($4, files_deleted),
    files_failed = COALESCE($5, files_failed),
    error_message = COALESCE($6, error_message)
WHERE id = $1
`

type UpdateCleanupJobStatusParams struct {
	ID             int32          `json:"id"`
	Status         sql.NullString `json:"status"`
	FilesProcessed sql.NullInt32  `json:"filesProcessed"`
	FilesDeleted   sql.NullInt32  `json:"filesDeleted"`
	FilesFailed    sql.NullInt32  `json:"filesFailed"`
	ErrorMessage   sql.NullString `json:"errorMessage"`
}

func (q *Queries) UpdateCleanupJobStatus(ctx context.Context, arg UpdateCleanupJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateCleanupJobStatus,
		arg.ID,
		arg.Status,
		arg.FilesProcessed,
		arg.FilesDeleted,
		arg.FilesFailed,
		arg.ErrorMessage,
	)
	return err
}

const updateCleanupJobStatusWithTiming = `-- name: UpdateCleanupJobStatusWithTiming :exec
UPDATE file_cleanup_jobs 
SET status = $2,
    started_at = CASE WHEN $2 = 'running' THEN CURRENT_TIMESTAMP ELSE started_at END,
    completed_at = CASE WHEN $2 IN ('completed', 'failed') THEN CURRENT_TIMESTAMP ELSE completed_at END,
    files_processed = COALESCE($3, files_processed),
    files_deleted = COALESCE($4, files_deleted),
    files_failed = COALESCE($5, files_failed),
    error_message = COALESCE($6, error_message)
WHERE id = $1
`

type UpdateCleanupJobStatusWithTimingParams struct {
	ID             int32          `json:"id"`
	Status         sql.NullString `json:"status"`
	FilesProcessed sql.NullInt32  `json:"filesProcessed"`
	FilesDeleted   sql.NullInt32  `json:"filesDeleted"`
	FilesFailed    sql.NullInt32  `json:"filesFailed"`
	ErrorMessage   sql.NullString `json:"errorMessage"`
}

func (q *Queries) UpdateCleanupJobStatusWithTiming(ctx context.Context, arg UpdateCleanupJobStatusWithTimingParams) error {
	_, err := q.db.ExecContext(ctx, updateCleanupJobStatusWithTiming,
		arg.ID,
		arg.Status,
		arg.FilesProcessed,
		arg.FilesDeleted,
		arg.FilesFailed,
		arg.ErrorMessage,
	)
	return err
}

const updateFileMetadata = `-- name: UpdateFileMetadata :exec
UPDATE file_uploads 
SET metadata = $2, tags = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateFileMetadataParams struct {
	ID       int32                 `json:"id"`
	Metadata pqtype.NullRawMessage `json:"metadata"`
	Tags     []string              `json:"tags"`
}

func (q *Queries) UpdateFileMetadata(ctx context.Context, arg UpdateFileMetadataParams) error {
	_, err := q.db.ExecContext(ctx, updateFileMetadata, arg.ID, arg.Metadata, pq.Array(arg.Tags))
	return err
}

const updateFileUploadStatus = `-- name: UpdateFileUploadStatus :exec
UPDATE file_uploads 
SET is_temporary = $2, is_orphaned = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateFileUploadStatusParams struct {
	ID          int32        `json:"id"`
	IsTemporary sql.NullBool `json:"isTemporary"`
	IsOrphaned  sql.NullBool `json:"isOrphaned"`
}

func (q *Queries) UpdateFileUploadStatus(ctx context.Context, arg UpdateFileUploadStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateFileUploadStatus, arg.ID, arg.IsTemporary, arg.IsOrphaned)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: 012-sales.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const checkInvoiceCodeExists = `-- name: CheckInvoiceCodeExists :one
SELECT EXISTS(SELECT 1 FROM sales_invoices WHERE invoice_code = $1)
`

func (q *Queries) CheckInvoiceCodeExists(ctx context.Context, invoiceCode string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkInvoiceCodeExists, invoiceCode)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkInvoiceExists = `-- name: CheckInvoiceExists :one

SELECT EXISTS(SELECT 1 FROM sales_invoices WHERE id = $1)
`

// ===== VALIDATION QUERIES =====
func (q *Queries) CheckInvoiceExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkInvoiceExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkProductExists = `-- name: CheckProductExists :one
SELECT EXISTS(SELECT 1 FROM products WHERE id = $1)
`

func (q *Queries) CheckProductExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkProductExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkProductStock = `-- name: CheckProductStock :one

SELECT product_quantity FROM products WHERE id = $1
`

// ===== INVENTORY INTEGRATION QUERIES =====
func (q *Queries) CheckProductStock(ctx context.Context, id int32) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, checkProductStock, id)
	var product_quantity sql.NullInt32
	err := row.Scan(&product_quantity)
	return product_quantity, err
}

const countCustomerOrders = `-- name: CountCustomerOrders :one
SELECT COUNT(*) FROM sales_invoices WHERE customer_phone = $1
`

func (q *Queries) CountCustomerOrders(ctx context.Context, customerPhone sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCustomerOrders, customerPhone)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingPaymentInvoices = `-- name: CountPendingPaymentInvoices :one
SELECT COUNT(*) FROM sales_invoices 
WHERE payment_status IN (1, 2) AND status != 5
`

func (q *Queries) CountPendingPaymentInvoices(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingPaymentInvoices)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSalesInvoices = `-- name: CountSalesInvoices :one
SELECT COUNT(*) FROM sales_invoices 
WHERE ($1::integer IS NULL OR status = $1)
  AND ($2::integer IS NULL OR payment_status = $2)
  AND ($3::text IS NULL OR customer_phone = $3)
  AND ($4::timestamp IS NULL OR invoice_date >= $4)
  AND ($5::timestamp IS NULL OR invoice_date <= $5)
`

type CountSalesInvoicesParams struct {
	Column1 int32     `json:"column1"`
	Column2 int32     `json:"column2"`
	Column3 string    `json:"column3"`
	Column4 time.Time `json:"column4"`
	Column5 time.Time `json:"column5"`
}

func (q *Queries) CountSalesInvoices(ctx context.Context, arg CountSalesInvoicesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSalesInvoices,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSalesInvoicesByStatus = `-- name: CountSalesInvoicesByStatus :one
SELECT COUNT(*) FROM sales_invoices WHERE status = $1
`

func (q *Queries) CountSalesInvoicesByStatus(ctx context.Context, status sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSalesInvoicesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSalesInvoice = `-- name: CreateSalesInvoice :one

INSERT INTO sales_invoices (
    invoice_code, customer_name, customer_phone, customer_email, customer_address,
    created_by_user_id, total_amount, total_items, discount_amount, final_amount,
    payment_method, payment_status, notes, status, invoice_date, delivery_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
) RETURNING id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at
`

type CreateSalesInvoiceParams struct {
	InvoiceCode     string         `json:"invoiceCode"`
	CustomerName    sql.NullString `json:"customerName"`
	CustomerPhone   sql.NullString `json:"customerPhone"`
	CustomerEmail   sql.NullString `json:"customerEmail"`
	CustomerAddress sql.NullString `json:"customerAddress"`
	CreatedByUserID int32          `json:"createdByUserId"`
	TotalAmount     string         `json:"totalAmount"`
	TotalItems      int32          `json:"totalItems"`
	DiscountAmount  sql.NullString `json:"discountAmount"`
	FinalAmount     string         `json:"finalAmount"`
	PaymentMethod   sql.NullString `json:"paymentMethod"`
	PaymentStatus   sql.NullInt32  `json:"paymentStatus"`
	Notes           sql.NullString `json:"notes"`
	Status          sql.NullInt32  `json:"status"`
	InvoiceDate     time.Time      `json:"invoiceDate"`
	DeliveryDate    sql.NullTime   `json:"deliveryDate"`
}

// ===== SALES INVOICE QUERIES =====
func (q *Queries) CreateSalesInvoice(ctx context.Context, arg CreateSalesInvoiceParams) (SalesInvoice, error) {
	row := q.db.QueryRowContext(ctx, createSalesInvoice,
		arg.InvoiceCode,
		arg.CustomerName,
		arg.CustomerPhone,
		arg.CustomerEmail,
		arg.CustomerAddress,
		arg.CreatedByUserID,
		arg.TotalAmount,
		arg.TotalItems,
		arg.DiscountAmount,
		arg.FinalAmount,
		arg.PaymentMethod,
		arg.PaymentStatus,
		arg.Notes,
		arg.Status,
		arg.InvoiceDate,
		arg.DeliveryDate,
	)
	var i SalesInvoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceCode,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.CustomerEmail,
		&i.CustomerAddress,
		&i.CreatedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.Notes,
		&i.Status,
		&i.InvoiceDate,
		&i.DeliveryDate,
		&i.CompletedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSalesInvoiceItem = `-- name: CreateSalesInvoiceItem :one

INSERT INTO sales_invoice_items (
    invoice_id, product_id, quantity, unit_price, total_price,
    discount_percent, discount_amount, final_price, notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, invoice_id, product_id, quantity, unit_price, total_price, discount_percent, discount_amount, final_price, notes, created_at, updated_at
`

type CreateSalesInvoiceItemParams struct {
	InvoiceID       int32          `json:"invoiceId"`
	ProductID       int32          `json:"productId"`
	Quantity        int32          `json:"quantity"`
	UnitPrice       string         `json:"unitPrice"`
	TotalPrice      string         `json:"totalPrice"`
	DiscountPercent sql.NullString `json:"discountPercent"`
	DiscountAmount  sql.NullString `json:"discountAmount"`
	FinalPrice      string         `json:"finalPrice"`
	Notes           sql.NullString `json:"notes"`
}

// ===== SALES INVOICE ITEMS QUERIES =====
func (q *Queries) CreateSalesInvoiceItem(ctx context.Context, arg CreateSalesInvoiceItemParams) (SalesInvoiceItem, error) {
	row := q.db.QueryRowContext(ctx, createSalesInvoiceItem,
		arg.InvoiceID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
		arg.DiscountPercent,
		arg.DiscountAmount,
		arg.FinalPrice,
		arg.Notes,
	)
	var i SalesInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.DiscountPercent,
		&i.DiscountAmount,
		&i.FinalPrice,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSalesInvoice = `-- name: DeleteSalesInvoice :exec
DELETE FROM sales_invoices WHERE id = $1
`

func (q *Queries) DeleteSalesInvoice(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSalesInvoice, id)
	return err
}

const deleteSalesInvoiceItem = `-- name: DeleteSalesInvoiceItem :exec
DELETE FROM sales_invoice_items WHERE id = $1
`

func (q *Queries) DeleteSalesInvoiceItem(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSalesInvoiceItem, id)
	return err
}

const deleteSalesInvoiceItemsByInvoiceID = `-- name: DeleteSalesInvoiceItemsByInvoiceID :exec
DELETE FROM sales_invoice_items WHERE invoice_id = $1
`

func (q *Queries) DeleteSalesInvoiceItemsByInvoiceID(ctx context.Context, invoiceID int32) error {
	_, err := q.db.ExecContext(ctx, deleteSalesInvoiceItemsByInvoiceID, invoiceID)
	return err
}

const getCustomerOrderHistory = `-- name: GetCustomerOrderHistory :many
SELECT id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at FROM sales_invoices 
WHERE customer_phone = $1
ORDER BY invoice_date DESC
LIMIT $2 OFFSET $3
`

type GetCustomerOrderHistoryParams struct {
	CustomerPhone sql.NullString `json:"customerPhone"`
	Limit         int32          `json:"limit"`
	Offset        int32          `json:"offset"`
}

func (q *Queries) GetCustomerOrderHistory(ctx context.Context, arg GetCustomerOrderHistoryParams) ([]SalesInvoice, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerOrderHistory, arg.CustomerPhone, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesInvoice
	for rows.Next() {
		var i SalesInvoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceCode,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.CustomerEmail,
			&i.CustomerAddress,
			&i.CreatedByUserID,
			&i.TotalAmount,
			&i.TotalItems,
			&i.DiscountAmount,
			&i.FinalAmount,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.Notes,
			&i.Status,
			&i.InvoiceDate,
			&i.DeliveryDate,
			&i.CompletedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceStatus = `-- name: GetInvoiceStatus :one
SELECT status FROM sales_invoices WHERE id = $1
`

func (q *Queries) GetInvoiceStatus(ctx context.Context, id int32) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getInvoiceStatus, id)
	var status sql.NullInt32
	err := row.Scan(&status)
	return status, err
}

const getLowStockProductsForSales = `-- name: GetLowStockProductsForSales :many
SELECT id, product_name, product_quantity 
FROM products 
WHERE product_quantity <= $1 
  AND is_published = true
ORDER BY product_quantity ASC
`

type GetLowStockProductsForSalesRow struct {
	ID              int32         `json:"id"`
	ProductName     string        `json:"productName"`
	ProductQuantity sql.NullInt32 `json:"productQuantity"`
}

func (q *Queries) GetLowStockProductsForSales(ctx context.Context, productQuantity sql.NullInt32) ([]GetLowStockProductsForSalesRow, error) {
	rows, err := q.db.QueryContext(ctx, getLowStockProductsForSales, productQuantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockProductsForSalesRow
	for rows.Next() {
		var i GetLowStockProductsForSalesRow
		if err := rows.Scan(&i.ID, &i.ProductName, &i.ProductQuantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPaymentInvoices = `-- name: GetPendingPaymentInvoices :many
SELECT id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at FROM sales_invoices 
WHERE payment_status IN (1, 2)  -- Chưa thanh toán hoặc thanh toán một phần
  AND status != 5  -- Không phải phiếu đã hủy
ORDER BY invoice_date ASC
LIMIT $1 OFFSET $2
`

type GetPendingPaymentInvoicesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetPendingPaymentInvoices(ctx context.Context, arg GetPendingPaymentInvoicesParams) ([]SalesInvoice, error) {
	rows, err := q.db.QueryContext(ctx, getPendingPaymentInvoices, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesInvoice
	for rows.Next() {
		var i SalesInvoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceCode,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.CustomerEmail,
			&i.CustomerAddress,
			&i.CreatedByUserID,
			&i.TotalAmount,
			&i.TotalItems,
			&i.DiscountAmount,
			&i.FinalAmount,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.Notes,
			&i.Status,
			&i.InvoiceDate,
			&i.DeliveryDate,
			&i.CompletedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesInvoice = `-- name: GetSalesInvoice :one
SELECT id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at FROM sales_invoices WHERE id = $1
`

func (q *Queries) GetSalesInvoice(ctx context.Context, id int32) (SalesInvoice, error) {
	row := q.db.QueryRowContext(ctx, getSalesInvoice, id)
	var i SalesInvoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceCode,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.CustomerEmail,
		&i.CustomerAddress,
		&i.CreatedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.Notes,
		&i.Status,
		&i.InvoiceDate,
		&i.DeliveryDate,
		&i.CompletedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesInvoiceByCode = `-- name: GetSalesInvoiceByCode :one
SELECT id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at FROM sales_invoices WHERE invoice_code = $1
`

func (q *Queries) GetSalesInvoiceByCode(ctx context.Context, invoiceCode string) (SalesInvoice, error) {
	row := q.db.QueryRowContext(ctx, getSalesInvoiceByCode, invoiceCode)
	var i SalesInvoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceCode,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.CustomerEmail,
		&i.CustomerAddress,
		&i.CreatedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.Notes,
		&i.Status,
		&i.InvoiceDate,
		&i.DeliveryDate,
		&i.CompletedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSalesInvoiceItem = `-- name: GetSalesInvoiceItem :one
SELECT sii.id, sii.invoice_id, sii.product_id, sii.quantity, sii.unit_price, sii.total_price, sii.discount_percent, sii.discount_amount, sii.final_price, sii.notes, sii.created_at, sii.updated_at, p.product_name 
FROM sales_invoice_items sii
LEFT JOIN products p ON sii.product_id = p.id
WHERE sii.id = $1
`

type GetSalesInvoiceItemRow struct {
	ID              int32          `json:"id"`
	InvoiceID       int32          `json:"invoiceId"`
	ProductID       int32          `json:"productId"`
	Quantity        int32          `json:"quantity"`
	UnitPrice       string         `json:"unitPrice"`
	TotalPrice      string         `json:"totalPrice"`
	DiscountPercent sql.NullString `json:"discountPercent"`
	DiscountAmount  sql.NullString `json:"discountAmount"`
	FinalPrice      string         `json:"finalPrice"`
	Notes           sql.NullString `json:"notes"`
	CreatedAt       time.Time      `json:"createdAt"`
	UpdatedAt       time.Time      `json:"updatedAt"`
	ProductName     sql.NullString `json:"productName"`
}

func (q *Queries) GetSalesInvoiceItem(ctx context.Context, id int32) (GetSalesInvoiceItemRow, error) {
	row := q.db.QueryRowContext(ctx, getSalesInvoiceItem, id)
	var i GetSalesInvoiceItemRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.DiscountPercent,
		&i.DiscountAmount,
		&i.FinalPrice,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductName,
	)
	return i, err
}

const getSalesInvoiceItems = `-- name: GetSalesInvoiceItems :many
SELECT sii.id, sii.invoice_id, sii.product_id, sii.quantity, sii.unit_price, sii.total_price, sii.discount_percent, sii.discount_amount, sii.final_price, sii.notes, sii.created_at, sii.updated_at, p.product_name 
FROM sales_invoice_items sii
LEFT JOIN products p ON sii.product_id = p.id
WHERE sii.invoice_id = $1 
ORDER BY sii.id
`

type GetSalesInvoiceItemsRow struct {
	ID              int32          `json:"id"`
	InvoiceID       int32          `json:"invoiceId"`
	ProductID       int32          `json:"productId"`
	Quantity        int32          `json:"quantity"`
	UnitPrice       string         `json:"unitPrice"`
	TotalPrice      string         `json:"totalPrice"`
	DiscountPercent sql.NullString `json:"discountPercent"`
	DiscountAmount  sql.NullString `json:"discountAmount"`
	FinalPrice      string         `json:"finalPrice"`
	Notes           sql.NullString `json:"notes"`
	CreatedAt       time.Time      `json:"createdAt"`
	UpdatedAt       time.Time      `json:"updatedAt"`
	ProductName     sql.NullString `json:"productName"`
}

func (q *Queries) GetSalesInvoiceItems(ctx context.Context, invoiceID int32) ([]GetSalesInvoiceItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalesInvoiceItems, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesInvoiceItemsRow
	for rows.Next() {
		var i GetSalesInvoiceItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.DiscountPercent,
			&i.DiscountAmount,
			&i.FinalPrice,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesInvoicesByDateRange = `-- name: GetSalesInvoicesByDateRange :many

SELECT id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at FROM sales_invoices 
WHERE invoice_date >= $1 AND invoice_date <= $2
  AND status != 5  -- Không tính phiếu đã hủy
ORDER BY invoice_date DESC
`

type GetSalesInvoicesByDateRangeParams struct {
	InvoiceDate   time.Time `json:"invoiceDate"`
	InvoiceDate_2 time.Time `json:"invoiceDate2"`
}

// ===== SALES REPORTS QUERIES =====
func (q *Queries) GetSalesInvoicesByDateRange(ctx context.Context, arg GetSalesInvoicesByDateRangeParams) ([]SalesInvoice, error) {
	rows, err := q.db.QueryContext(ctx, getSalesInvoicesByDateRange, arg.InvoiceDate, arg.InvoiceDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesInvoice
	for rows.Next() {
		var i SalesInvoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceCode,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.CustomerEmail,
			&i.CustomerAddress,
			&i.CreatedByUserID,
			&i.TotalAmount,
			&i.TotalItems,
			&i.DiscountAmount,
			&i.FinalAmount,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.Notes,
			&i.Status,
			&i.InvoiceDate,
			&i.DeliveryDate,
			&i.CompletedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesInvoicesByStatus = `-- name: GetSalesInvoicesByStatus :many
SELECT id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at FROM sales_invoices 
WHERE status = $1
ORDER BY invoice_date DESC
LIMIT $2 OFFSET $3
`

type GetSalesInvoicesByStatusParams struct {
	Status sql.NullInt32 `json:"status"`
	Limit  int32         `json:"limit"`
	Offset int32         `json:"offset"`
}

func (q *Queries) GetSalesInvoicesByStatus(ctx context.Context, arg GetSalesInvoicesByStatusParams) ([]SalesInvoice, error) {
	rows, err := q.db.QueryContext(ctx, getSalesInvoicesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesInvoice
	for rows.Next() {
		var i SalesInvoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceCode,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.CustomerEmail,
			&i.CustomerAddress,
			&i.CreatedByUserID,
			&i.TotalAmount,
			&i.TotalItems,
			&i.DiscountAmount,
			&i.FinalAmount,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.Notes,
			&i.Status,
			&i.InvoiceDate,
			&i.DeliveryDate,
			&i.CompletedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesRevenueByDateRange = `-- name: GetSalesRevenueByDateRange :one
SELECT 
    COUNT(DISTINCT si.id) as total_invoices,
    SUM(si.final_amount::numeric) as total_revenue,
    SUM(si.total_items) as total_items_sold,
    AVG(si.final_amount::numeric) as average_order_value
FROM sales_invoices si
WHERE si.status IN (3, 4)  -- Chỉ tính phiếu đã giao hàng hoặc hoàn thành
  AND si.invoice_date >= $1 
  AND si.invoice_date <= $2
`

type GetSalesRevenueByDateRangeParams struct {
	InvoiceDate   time.Time `json:"invoiceDate"`
	InvoiceDate_2 time.Time `json:"invoiceDate2"`
}

type GetSalesRevenueByDateRangeRow struct {
	TotalInvoices     int64   `json:"totalInvoices"`
	TotalRevenue      int64   `json:"totalRevenue"`
	TotalItemsSold    int64   `json:"totalItemsSold"`
	AverageOrderValue float64 `json:"averageOrderValue"`
}

func (q *Queries) GetSalesRevenueByDateRange(ctx context.Context, arg GetSalesRevenueByDateRangeParams) (GetSalesRevenueByDateRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getSalesRevenueByDateRange, arg.InvoiceDate, arg.InvoiceDate_2)
	var i GetSalesRevenueByDateRangeRow
	err := row.Scan(
		&i.TotalInvoices,
		&i.TotalRevenue,
		&i.TotalItemsSold,
		&i.AverageOrderValue,
	)
	return i, err
}

const getTopSellingProducts = `-- name: GetTopSellingProducts :many
SELECT p.id, p.product_name, 
       SUM(sii.quantity) as total_quantity_sold,
       SUM(sii.final_price::numeric) as total_revenue
FROM sales_invoice_items sii
JOIN products p ON sii.product_id = p.id
JOIN sales_invoices si ON sii.invoice_id = si.id
WHERE si.status IN (3, 4)  -- Chỉ tính phiếu đã giao hàng hoặc hoàn thành
  AND ($1::timestamp IS NULL OR si.invoice_date >= $1)
  AND ($2::timestamp IS NULL OR si.invoice_date <= $2)
GROUP BY p.id, p.product_name
ORDER BY total_revenue DESC
LIMIT $3
`

type GetTopSellingProductsParams struct {
	Column1 time.Time `json:"column1"`
	Column2 time.Time `json:"column2"`
	Limit   int32     `json:"limit"`
}

type GetTopSellingProductsRow struct {
	ID                int32  `json:"id"`
	ProductName       string `json:"productName"`
	TotalQuantitySold int64  `json:"totalQuantitySold"`
	TotalRevenue      int64  `json:"totalRevenue"`
}

func (q *Queries) GetTopSellingProducts(ctx context.Context, arg GetTopSellingProductsParams) ([]GetTopSellingProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSellingProducts, arg.Column1, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingProductsRow
	for rows.Next() {
		var i GetTopSellingProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.TotalQuantitySold,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSalesInvoices = `-- name: ListSalesInvoices :many
SELECT id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at FROM sales_invoices 
WHERE ($1::integer IS NULL OR status = $1)
  AND ($2::integer IS NULL OR payment_status = $2)
  AND ($3::text IS NULL OR customer_phone = $3)
  AND ($4::timestamp IS NULL OR invoice_date >= $4)
  AND ($5::timestamp IS NULL OR invoice_date <= $5)
ORDER BY invoice_date DESC, id DESC
LIMIT $6 OFFSET $7
`

type ListSalesInvoicesParams struct {
	Column1 int32     `json:"column1"`
	Column2 int32     `json:"column2"`
	Column3 string    `json:"column3"`
	Column4 time.Time `json:"column4"`
	Column5 time.Time `json:"column5"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListSalesInvoices(ctx context.Context, arg ListSalesInvoicesParams) ([]SalesInvoice, error) {
	rows, err := q.db.QueryContext(ctx, listSalesInvoices,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SalesInvoice
	for rows.Next() {
		var i SalesInvoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceCode,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.CustomerEmail,
			&i.CustomerAddress,
			&i.CreatedByUserID,
			&i.TotalAmount,
			&i.TotalItems,
			&i.DiscountAmount,
			&i.FinalAmount,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.Notes,
			&i.Status,
			&i.InvoiceDate,
			&i.DeliveryDate,
			&i.CompletedDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductStockAfterCancel = `-- name: UpdateProductStockAfterCancel :exec
UPDATE products 
SET product_quantity = product_quantity + $2,
    product_selled = GREATEST(product_selled - $2, 0),
    updated_at = NOW()
WHERE id = $1
`

type UpdateProductStockAfterCancelParams struct {
	ID              int32         `json:"id"`
	ProductQuantity sql.NullInt32 `json:"productQuantity"`
}

func (q *Queries) UpdateProductStockAfterCancel(ctx context.Context, arg UpdateProductStockAfterCancelParams) error {
	_, err := q.db.ExecContext(ctx, updateProductStockAfterCancel, arg.ID, arg.ProductQuantity)
	return err
}

const updateProductStockAfterSale = `-- name: UpdateProductStockAfterSale :exec
UPDATE products 
SET product_quantity = product_quantity - $2,
    product_selled = product_selled + $2,
    updated_at = NOW()
WHERE id = $1 AND product_quantity >= $2
`

type UpdateProductStockAfterSaleParams struct {
	ID              int32         `json:"id"`
	ProductQuantity sql.NullInt32 `json:"productQuantity"`
}

func (q *Queries) UpdateProductStockAfterSale(ctx context.Context, arg UpdateProductStockAfterSaleParams) error {
	_, err := q.db.ExecContext(ctx, updateProductStockAfterSale, arg.ID, arg.ProductQuantity)
	return err
}

const updateSalesInvoice = `-- name: UpdateSalesInvoice :one
UPDATE sales_invoices 
SET customer_name = COALESCE($2, customer_name),
    customer_phone = COALESCE($3, customer_phone),
    customer_email = COALESCE($4, customer_email),
    customer_address = COALESCE($5, customer_address),
    total_amount = COALESCE($6, total_amount),
    total_items = COALESCE($7, total_items),
    discount_amount = COALESCE($8, discount_amount),
    final_amount = COALESCE($9, final_amount),
    payment_method = COALESCE($10, payment_method),
    payment_status = COALESCE($11, payment_status),
    notes = COALESCE($12, notes),
    status = COALESCE($13, status),
    delivery_date = COALESCE($14, delivery_date),
    completed_date = COALESCE($15, completed_date),
    updated_at = NOW()
WHERE id = $1 
RETURNING id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at
`

type UpdateSalesInvoiceParams struct {
	ID              int32          `json:"id"`
	CustomerName    sql.NullString `json:"customerName"`
	CustomerPhone   sql.NullString `json:"customerPhone"`
	CustomerEmail   sql.NullString `json:"customerEmail"`
	CustomerAddress sql.NullString `json:"customerAddress"`
	TotalAmount     string         `json:"totalAmount"`
	TotalItems      int32          `json:"totalItems"`
	DiscountAmount  sql.NullString `json:"discountAmount"`
	FinalAmount     string         `json:"finalAmount"`
	PaymentMethod   sql.NullString `json:"paymentMethod"`
	PaymentStatus   sql.NullInt32  `json:"paymentStatus"`
	Notes           sql.NullString `json:"notes"`
	Status          sql.NullInt32  `json:"status"`
	DeliveryDate    sql.NullTime   `json:"deliveryDate"`
	CompletedDate   sql.NullTime   `json:"completedDate"`
}

func (q *Queries) UpdateSalesInvoice(ctx context.Context, arg UpdateSalesInvoiceParams) (SalesInvoice, error) {
	row := q.db.QueryRowContext(ctx, updateSalesInvoice,
		arg.ID,
		arg.CustomerName,
		arg.CustomerPhone,
		arg.CustomerEmail,
		arg.CustomerAddress,
		arg.TotalAmount,
		arg.TotalItems,
		arg.DiscountAmount,
		arg.FinalAmount,
		arg.PaymentMethod,
		arg.PaymentStatus,
		arg.Notes,
		arg.Status,
		arg.DeliveryDate,
		arg.CompletedDate,
	)
	var i SalesInvoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceCode,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.CustomerEmail,
		&i.CustomerAddress,
		&i.CreatedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.Notes,
		&i.Status,
		&i.InvoiceDate,
		&i.DeliveryDate,
		&i.CompletedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSalesInvoiceItem = `-- name: UpdateSalesInvoiceItem :one
UPDATE sales_invoice_items 
SET quantity = COALESCE($2, quantity),
    unit_price = COALESCE($3, unit_price),
    total_price = COALESCE($4, total_price),
    discount_percent = COALESCE($5, discount_percent),
    discount_amount = COALESCE($6, discount_amount),
    final_price = COALESCE($7, final_price),
    notes = COALESCE($8, notes),
    updated_at = NOW()
WHERE id = $1 
RETURNING id, invoice_id, product_id, quantity, unit_price, total_price, discount_percent, discount_amount, final_price, notes, created_at, updated_at
`

type UpdateSalesInvoiceItemParams struct {
	ID              int32          `json:"id"`
	Quantity        int32          `json:"quantity"`
	UnitPrice       string         `json:"unitPrice"`
	TotalPrice      string         `json:"totalPrice"`
	DiscountPercent sql.NullString `json:"discountPercent"`
	DiscountAmount  sql.NullString `json:"discountAmount"`
	FinalPrice      string         `json:"finalPrice"`
	Notes           sql.NullString `json:"notes"`
}

func (q *Queries) UpdateSalesInvoiceItem(ctx context.Context, arg UpdateSalesInvoiceItemParams) (SalesInvoiceItem, error) {
	row := q.db.QueryRowContext(ctx, updateSalesInvoiceItem,
		arg.ID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
		arg.DiscountPercent,
		arg.DiscountAmount,
		arg.FinalPrice,
		arg.Notes,
	)
	var i SalesInvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
		&i.DiscountPercent,
		&i.DiscountAmount,
		&i.FinalPrice,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSalesInvoicePaymentStatus = `-- name: UpdateSalesInvoicePaymentStatus :one
UPDATE sales_invoices 
SET payment_status = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at
`

type UpdateSalesInvoicePaymentStatusParams struct {
	ID            int32         `json:"id"`
	PaymentStatus sql.NullInt32 `json:"paymentStatus"`
}

func (q *Queries) UpdateSalesInvoicePaymentStatus(ctx context.Context, arg UpdateSalesInvoicePaymentStatusParams) (SalesInvoice, error) {
	row := q.db.QueryRowContext(ctx, updateSalesInvoicePaymentStatus, arg.ID, arg.PaymentStatus)
	var i SalesInvoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceCode,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.CustomerEmail,
		&i.CustomerAddress,
		&i.CreatedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.Notes,
		&i.Status,
		&i.InvoiceDate,
		&i.DeliveryDate,
		&i.CompletedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSalesInvoiceStatus = `-- name: UpdateSalesInvoiceStatus :one
UPDATE sales_invoices 
SET status = $2, updated_at = NOW()
WHERE id = $1 
RETURNING id, invoice_code, customer_name, customer_phone, customer_email, customer_address, created_by_user_id, total_amount, total_items, discount_amount, final_amount, payment_method, payment_status, notes, status, invoice_date, delivery_date, completed_date, created_at, updated_at
`

type UpdateSalesInvoiceStatusParams struct {
	ID     int32         `json:"id"`
	Status sql.NullInt32 `json:"status"`
}

func (q *Queries) UpdateSalesInvoiceStatus(ctx context.Context, arg UpdateSalesInvoiceStatusParams) (SalesInvoice, error) {
	row := q.db.QueryRowContext(ctx, updateSalesInvoiceStatus, arg.ID, arg.Status)
	var i SalesInvoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceCode,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.CustomerEmail,
		&i.CustomerAddress,
		&i.CreatedByUserID,
		&i.TotalAmount,
		&i.TotalItems,
		&i.DiscountAmount,
		&i.FinalAmount,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.Notes,
		&i.Status,
		&i.InvoiceDate,
		&i.DeliveryDate,
		&i.CompletedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
